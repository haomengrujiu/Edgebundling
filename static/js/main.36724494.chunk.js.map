{"version":3,"sources":["components/row/leftColumn/map/ABlevel.js","components/row/leftColumn/map/EdgeBundling.js","components/row/leftColumn/map/ComputeData.js","components/row/leftColumn/map/index2.js","components/row/leftColumn/map/ComputeNetflow.js","components/row/leftColumn/map/index.js","components/row/leftColumn/map/Layer.js","components/topnav/index.js","components/row/leftColumn/index.js","components/row/rightColumn/index.js","components/row/index.js","components/footer/index.js","index.js"],"names":["ABlevel","dev","city","str","A","indexOf","B","console","log","AccResolution","KernelSize","GradientW","KernelEdgeBundling","data_nodes","data_edges","SplattedAccMap","subdivision_points_for_edge","splitDistance","removeDistance","Kernel","getKernel3D","attractionFactor","iteration","xMin","xMax","yMin","yMax","zMin","zMax","auto_adaption","filter_self_loops","edgelist","filtered_edge_list","e","length","source","x","target","y","push","euclidean_distance3D","p","q","Math","sqrt","pow","z","toInt32","help","i","floor","j","round","KernSize","k","temp1","temp2","temp3","centerDist","max","abs","forcebundle","key","item","min","NodeNormalize3D","id","value","initialize_edge_subdivisions3D","bundle3D","line","point","antiNormalize3D","tempVertex","tmpVertexList","currentVert","nextVert","dist","Resample3D","AccMap","ComputeSplatting3D","pointIndex","localGradient","GetLocalGradient3D","gradientNormalize3D","ApplyGradient3D","SmoothTrajectories3D","gradientW","localGradient1","localGradient2","localGradient3","offsetIndex","localDensity","l","nodes","nl","arguments","edges","ll","splitDis","removeDis","resolution","kernelSize","attract","autoAdapt","getKernel","euclidean_distance","NodeNormalize","initialize_edge_subdivisions","forEach","edge","bundle","antiNormalize","Resample","ComputeSplatting","GetLocalGradient","gradientNormalize","ApplyGradient","SmoothTrajectories","Kernel2","isFirst","AccMap2","GetForceGradient3D","px","py","pz","startX","startY","startZ","endX","endY","endZ","statistics","minDist","num","nx","ny","nz","undefined","FG1","GetForceGradient3D_ByNum","FG2","FG3","gradient1","gradient","dist1","gradient2","dist2","gradient3","dist3","graSum","index","power","preIndex","nexIndex","prePoint","curPoint","nexPoint","cpX","cpY","cpZ","fx","fy","fz","DirectionAccMap","Resample3D_const","DAccMap","lineIndex","vx","vy","vz","DX","DY","DZ","curIndex","cx","cy","cz","curdist","dX","dY","dZ","localDirectionDensity","localDist","GaussianDistribute","pointDistK","a","PI","exp","getGaussianKernel3D","time","timeEnd","lineLength","l1","l2","distK","sum","attr","coordinatesData","ComputeData","this","ColorEB","d3","ColorDC","typeHeight","isSkipZero","isSkipBusinessCore","isCheckPathNegative","isMerge_FT_Edeges","china","typeLine","allNodes","data","processRawData","rawData","generateTypeData","maxValue","EBResults","computeEBResults","DCResults","computeDCResults","split","maxBdUtilization","maxTraffic","valueType","path","color","setColor","width","getWidth","info","np","get_China_Data","bdUtilization","traffic","bandwidth","merge_Same_Edges","merge_FT_Edges","frequency","converSourceTarget","from_city","to_city","from_coordinates","to_coordinates","trafficLimit","bandwidthLimit","height","features","withHeightChinaPath","fea","geometry","coordinates","geo","newPath","obj","sumObj","from_dev","from_level","from_port","to_dev","to_level","to_port","flStr","tlStr","fromPlane","getLevel","toPlane","planeStr","typeStr","f_cityDev","t_cityDev","f_nodeType","t_nodeType","type","results","FINAL","links_traffic","links_bd","tx","ty","rType1","rType2","r1","KernelEdgeBundling2D","r2","convert2D","ftype","ttype","tz","KernelEdgeBundling3D_ADEB2","ABresult","Mresult","planeA","planeB","from","to","t","rgbArr","f2t","replace","parseInt","nodeObj","nodeStr","name","limit","levelHeight","indexObj","mergesData","isNaN","edgeStr","mergeFTData","indexObj_FT","fromStr","toStr","FT","TF","setMapProgress","temp_city","temp_dev","temp_level","temp_port","Component","Netflow","NETFLOW_DATA","format","merge_Same_Edge","merge_FT_Edege","generateTypeEdge","computeNodes","strArr","source_level","target_level","temp_source","newData","str1","str2","nodeLevel","typeEdge","newType","links","KernelEdgeBundling3D_ADEB","nodesValue","attr1","attr2","fillColor","maxNodeVlue","radius","getRadius","getColor","newResults","g","b","g2b","Map","props","changeMapLayers","layers","setState","state","INITIAL_VIEW_STATE","zoom","rotationOrbit","rotationX","minRotationX","maxRotationX","minZoom","maxZoom","PubSub","publish","DidMount","views","OrbitView","orbitAxis","initialViewState","controller","style","top","left","allLayers","currentScatterData","currentEdgeData","currentDataKind","Layer","receiveButtonInfo","subscribe","_","stateObj","button","buttonState","Topnav","receiveDataInfo","netflowResults","receiveChangeMapLayers","getPathLayer","paramObj","layerID","opacity","filter2D","PathLayer","pickable","widthScale","widthMinPixels","widthMaxPixels","getPath","d","billboard","autoHighlight","highlightColor","onClick","showInfo","getScatterPlotLayer","ScatterplotLayer","getFillColor","getLineColor","getPosition","position","lineWidthMinPixels","radiusMaxPixels","radiusMinPixels","radiusScale","stroked","onHover","highlightPoint_Edge","event","clickScatter","getTextLayer","TextLayer","getText","characterSet","getSize","getAngle","sizeScale","sizeMinPixels","getTextAnchor","getAlignmentBaseline","getPolygonLayer","PolygonLayer","filled","wireframe","getPolygon","contour","getLineWidth","getRingLayer","object","alert","String","preState","netflow","exist","picked","scatterInfo","updateHighlightPoint_Edge","cancelHighlight","updateHighlightEdge","edgeInfo","DC","EB","dataKind","plane","edgeKind","highlightEdges","highlightScatter","ScatterObj","cityArr","scatterData","pathLayerParamObj","pathLayer","scatterLayerParamObj","scatterLayer","combineLayers","pathLayers","netflowLayers","ringLayers","scatterLayers","rightClickLayers","rightClickScatter","leftButton","scatterID","edgesData","layer","bind","receiveRightInfo","setDataKind","setRightColumnDataKind","maxNodeTraffic","maxNodeBd","node","receiveMapDidMount","computeLayers","getButtonColor","deHighlightColor","updateButtonState","other","bd","edgeKindArr","currentPlane","scatterSet","Set","edgeKindData","computeScatterData","netflowExist","has","ringID","x0","y0","scatterParamObj","textParamObj","textLayer","polygonArr","minX","maxX","minY","maxY","A0","A1","B0","B1","polygonData0","polygonData1","polygonData2","polygonData3","normalPlaneColor","corePlaneColor","hasA","hasB","polygonLayerID0","polygonLayerID1","polygonLayerID2","polygonLayerID3","textLayers","polygonLayers","getScatterRadius","kind","infoArr","add","r_t","r_b","sendButtonStateInfo","className","backgroundColor","LeftColumn","isFinish","RightColumn","nodeThreshold","Infinity","edgeThreshold","planeDiffThreshold","nodeRef","React","createRef","edgeRef","doublePlaneRef","dk","myNodes","myEdges","myPlane","processProv2City","provData","provCityData","cityData","city2prov","cityName","provID","ProID","provName","updateTable","ref","thresholdValue","current","updateMyNodes","updateMyEdges","updateDoublePlane","ID","sort","edgeArr","prov2city","prov","sumValue","percentage","diff","hoverTr","currentHover","leaveTr","title","content","placeholder","border","map","onMouseOver","onMouseLeave","toFixed","Row","Footer","ReactDOM","render","StrictMode","document","getElementById","setTimeout","getResults","ComputeNetflow"],"mappings":"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,OACrB7L,EAAK6L,OAAS2D,EAEdxP,EAAK2L,WAAa3L,EAAK8L,SACvB9L,EAAK8L,SAAW2D,EAEhBzP,EAAK4L,UAAY5L,EAAK+L,QACtB/L,EAAK+L,QAAU2D,U,KApeVzH,EACVK,WAAa,CAAE,IAAO,GAAI,IAAO,EAAG,EAAK,IAAK,IAAO,IAAK,IAAO,K,WCR3CqH,YCFjC,IAAI,IAAI5H,KAAQC,EACZA,EAAgBD,GAAMjK,EAA4B,EAAzBkK,EAAgBD,GAAMjK,EAC/CkK,EAAgBD,GAAM/J,EAA4B,EAAzBgK,EAAgBD,GAAM/J,E,IAG9B4R,E,WAwHb,aAAc,yBAvHlBC,aAAe,CACX,wFACA,uFACA,8FACA,yFACA,wFACA,yFACA,wFACA,yFACA,wFACA,wFACA,uFACA,uFACA,wFACA,uFACA,wFACA,wFACA,wFACA,sFACA,uFACA,uFACA,sFACA,wFACA,sFACA,yFACA,uFACA,wFACA,8FACA,8FACA,yFACA,wFACA,sFACA,wFACA,sFACA,0FACA,sFACA,8FACA,wFACA,uFACA,8FACA,uFACA,uFACA,wFACA,uFACA,yFACA,yFACA,wFACA,uFACA,wFACA,wFACA,wFACA,wFACA,wFACA,wFACA,wFACA,wFACA,wFACA,uFACA,uFACA,uFACA,8FACA,uFACA,uFACA,6FACA,uFACA,uFACA,uFACA,wFACA,uFACA,yFACA,yFACA,uFACA,uFACA,uFACA,wFACA,uFACA,uFACA,uFACA,wFACA,qFACA,wFACA,wFACA,uFACA,uFACA,uFACA,6FACA,sFACA,sFACA,qFACA,qFACA,sFACA,wFACA,uFACA,+FACA,uFACA,yFACA,wFACA,yFACA,yFACA,wFACA,wFACA,wFACA,yFACA,wFACA,yFACA,yFACA,wFACA,uFACA,uFACA,wFACA,wFACA,uFACA,0FACA,yFACA,wFACA,wFACA,+FACA,0FAGI3H,KAAKO,qBAAsB,EAC3BP,KAAKI,WAAaL,EAAYK,WAC9BJ,KAAK4H,SACL5H,KAAK6H,kBACL7H,KAAK8H,iBACL9H,KAAK+H,mBACL/H,KAAKkB,mBACLlB,KAAKgI,e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","file":"static/js/main.36724494.chunk.js","sourcesContent":["export default class ABlevel{ //return 0,是第A层，1是第B层，-1是中间层M,目前中间层只有运城\r\n    static A = [\r\n        \"235,北京\",\r\n        \"1385,广州\",\r\n        \"1129,上海\",\r\n        \"5004,海口\",\r\n        \"2194,安庆\",\r\n        \"5090,柳州\",\r\n        \"3739,昆明\",\r\n        \"4864,拉萨\",\r\n        \"4654,成都\",\r\n        \"35882,贵阳\",\r\n        \"3988,兰州\",\r\n        \"3576,长沙\",\r\n        \"3416,合肥\",\r\n        \"3168,南昌\",\r\n        \"3840,厦门\",\r\n        \"4044,重庆\",\r\n        \"3919,银川\",\r\n        \"5171,武汉\",\r\n        \"3914,西宁\",\r\n        \"4515,西安\",\r\n        \"2194,唐山\",\r\n        \"4448,无锡\",\r\n        \"36539,杭州\",\r\n        \"4031,乌鲁木齐\",\r\n        \"36272,太原\",\r\n        \"2994,洛阳\",\r\n        \"3443,青岛\",\r\n        \"2701,大连\",\r\n        \"36422,天津\",\r\n        \"36036,长春\",\r\n        \"591,绥化\",\r\n        \"180,呼和浩特\",\r\n        \"63,通辽\",\r\n        \"1536,鄂尔多斯\",\r\n    ]\r\n    static B = [\r\n        \"1756,北京\",\r\n        \"1536,广州\",\r\n        \"1257,上海\",\r\n        \"5013,海口\",\r\n        \"3935,南充\",\r\n        \"4872,拉萨\",\r\n        \"3190,南昌\",\r\n        \"3903,西宁\",\r\n        \"4013,乌鲁木齐\",\r\n        \"3304,合肥\",\r\n        \"3941,兰州\",\r\n        \"3935,银川\",\r\n        \"3757,福州\",\r\n        \"3643,武汉\",\r\n        \"5242,西安\",\r\n        \"2360,太原\",\r\n        \"3615,长沙\",\r\n        \"3227,济南\",\r\n        \"4561,成都\",\r\n        \"47,来宾\",\r\n        \"5058,南宁\",\r\n        \"96,呼和浩特\",\r\n        \"4069,宁波\",\r\n        \"4360,南京\",\r\n        \"2549,沈阳\",\r\n        \"4953,贵阳\",\r\n        \"3213,重庆\",\r\n        \"2841,郑州\",\r\n        \"474,哈尔滨\",\r\n        \"2473,吉林\",\r\n        \"2050,石家庄\",\r\n        \"47,通辽\",\r\n        \"787,玉溪\",\r\n        \"1997,天津\",\r\n    ]\r\n    static getLevel(dev,city){\r\n        let str = dev + \",\" + city\r\n        if (ABlevel.A.indexOf(str) > -1) return \"A\"\r\n        if (ABlevel.B.indexOf(str) > -1) return \"B\"\r\n        console.log(\"没有找到dev的level：\", str)\r\n        return \"M\"\r\n    }\r\n}","const iteration3D = 20 //20\r\nconst iteration2D = 20//20\r\nconst smoothNum = 50\r\nconst AccResolution = 150\r\nconst KernelSize = 11\r\nconst GradientW = 11\r\nexport default class KernelEdgeBundling {\r\n  static KernelEdgeBundling3D() {\r\n    var data_nodes = {}, // {'nodeid':{'x':,'y':},..}\r\n      data_edges = [], // [{'source':'nodeid1', 'target':'nodeid2'},..]\r\n      SplattedAccMap = [],\r\n      subdivision_points_for_edge = [],\r\n      splitDistance = 0.01, // 增大或减小, 都会变松. 增大会稍微平滑一点.\r\n      removeDistance = 0.006, // 增大或减小, 都会变松. 增大会平滑些.\r\n      // AccResolution = 100, // 增大, 股数变多. 减小, 股数变小.\r\n      // KernelSize = 50, // 增大, 变松. 减小, 变紧. 默认15, 设为20会平滑一些\r\n      Kernel = getKernel3D(KernelSize),\r\n      // GradientW = 100, // 增大, 变松. 减小, 变紧.\r\n      attractionFactor = 2.0, // 增大, 变紧. 减小, 变松\r\n      iteration = iteration3D,//10,//20\r\n      minn = 100000000000000000,\r\n      maxn = -10000,\r\n      xMin = 100000,\r\n      xMax = -100000,\r\n      yMin = 1000000,\r\n      yMax = -1000000,\r\n\r\n      zMin = 1000000,\r\n      zMax = -1000000,\r\n\r\n      auto_adaption = false\r\n\r\n    /*** Helper Methods ***/\r\n    function filter_self_loops(edgelist) {\r\n      var filtered_edge_list = []\r\n      for (var e = 0; e < edgelist.length; e++) {\r\n        if (\r\n          data_nodes[edgelist[e].source].x !=\r\n          data_nodes[edgelist[e].target].x ||\r\n          data_nodes[edgelist[e].source].y != data_nodes[edgelist[e].target].y\r\n        ) {\r\n          //or smaller than eps\r\n          filtered_edge_list.push(edgelist[e])\r\n        }\r\n      }\r\n\r\n      return filtered_edge_list\r\n    }\r\n\r\n\r\n    function euclidean_distance3D(p, q) {\r\n      return Math.sqrt(Math.pow(p.x - q.x, 2) + Math.pow(p.y - q.y, 2) + Math.pow(p.z - q.z, 2))\r\n    }\r\n\r\n    function toInt32(x) {\r\n      /*** C# convert.ToInt32 ***/\r\n      function help(x) {\r\n        let i = Math.floor(x)\r\n        let j = i + 1\r\n        let z = Math.round(x)\r\n        if (x == (i + j) / 2) {\r\n          if (i % 2 == 0) return i\r\n          return j\r\n        }\r\n        return z\r\n      }\r\n      if (x >= 0) return help(x)\r\n      else {\r\n        x = -x\r\n        return -help(x)\r\n      }\r\n    }\r\n    /*** ********************** ***/\r\n\r\n    /*** Initialization Methods ***/\r\n    function getKernel3D(KernSize) {\r\n      let Kernel = []\r\n      for (let i = 0; i < KernSize * KernSize * KernSize; i++) Kernel.push(0)\r\n      for (let i = 0; i < KernSize * KernSize * KernSize; i += KernSize * KernSize) {\r\n        for (let j = 0; j < KernSize * KernSize; j += KernSize) {\r\n          for (let k = 0; k < KernSize; k++) {\r\n            let temp1 = k - (KernSize - 1) / 2\r\n            let temp2 = j / KernSize - (KernSize - 1) / 2\r\n            let temp3 = i / KernSize / KernSize - (KernSize - 1) / 2\r\n            let centerDist = Math.sqrt(temp1 * temp1 + temp2 * temp2 + temp3 * temp3)\r\n            Kernel[i + j + k] = Math.max(\r\n              0,\r\n              1 - Math.abs((2 / (KernSize - 1)) * centerDist)\r\n            )\r\n          }\r\n        }\r\n      }\r\n      return Kernel\r\n    }\r\n\r\n\r\n    function NodeNormalize3D() {\r\n      for (var key in data_nodes) {\r\n        var item = data_nodes[key]\r\n        xMin = Math.min(xMin, item.x)\r\n        xMax = Math.max(xMax, item.x)\r\n\r\n        yMin = Math.min(yMin, item.y)\r\n        yMax = Math.max(yMax, item.y)\r\n\r\n        zMin = Math.min(zMin, item.z)\r\n        zMax = Math.max(zMax, item.z)\r\n      }\r\n    }\r\n\r\n\r\n    function antiNormalize3D() {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let point of line) {\r\n          point.x = point.x * (xMax - xMin) + xMin\r\n          point.y = point.y * (yMax - yMin) + yMin\r\n          point.z = point.z * (zMax - zMin) + zMin\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    function initialize_edge_subdivisions3D() {\r\n      for (var i = 0; i < data_edges.length; i++) {\r\n        subdivision_points_for_edge[i] = []\r\n        subdivision_points_for_edge[i].push({\r\n          id: data_edges[i].source,\r\n          x: (data_nodes[data_edges[i].source].x - xMin) / (xMax - xMin),\r\n          y: (data_nodes[data_edges[i].source].y - yMin) / (yMax - yMin),\r\n          z: (data_nodes[data_edges[i].source].z - zMin) / (zMax - zMin),\r\n          value: data_edges[i].value,\r\n        })\r\n\r\n        subdivision_points_for_edge[i].push({\r\n          id: data_edges[i].target,\r\n          x: (data_nodes[data_edges[i].target].x - xMin) / (xMax - xMin),\r\n          y: (data_nodes[data_edges[i].target].y - yMin) / (yMax - yMin),\r\n          z: (data_nodes[data_edges[i].target].z - zMin) / (zMax - zMin),\r\n          value: data_edges[i].value,\r\n        })\r\n      }\r\n    }\r\n\r\n    /*** Main Bundling Loop Methods ***/\r\n    var forcebundle = function () {\r\n      //NodeNormalize()\r\n      NodeNormalize3D()\r\n\r\n      //initialize_edge_subdivisions()\r\n      initialize_edge_subdivisions3D()\r\n\r\n      //initializeBytes()\r\n\r\n      for (let i = 0; i < iteration; i++) {\r\n        if (auto_adaption == true && i == ~~(iteration * 0.6)) {\r\n          AccResolution = AccResolution * 2\r\n          KernelSize = KernelSize - 2\r\n          //Kernel = getKernel(KernelSize)\r\n          Kernel = getKernel3D(KernelSize)\r\n        }\r\n        bundle3D()\r\n\r\n      }\r\n\r\n      //antiNormalize()\r\n      antiNormalize3D()\r\n      return subdivision_points_for_edge\r\n    }\r\n    /*** ************************ ***/\r\n\r\n    /*** Force Calculation Methods ***/\r\n\r\n    function bundle3D() {\r\n\r\n      Resample3D(splitDistance, removeDistance)\r\n\r\n      // Splatting\r\n      //ComputeSplatting()\r\n      ComputeSplatting3D()\r\n\r\n      // // Apply Gradient\r\n      ApplyGradient3D(GradientW, attractionFactor, SplattedAccMap)\r\n\r\n      // Smooth trajectories\r\n      for (let i = 0; i < smoothNum; i++) {\r\n        SmoothTrajectories3D()\r\n      }\r\n    }\r\n\r\n\r\n    function Resample3D() {\r\n      let tempVertex = subdivision_points_for_edge\r\n      for (let i = 0; i < tempVertex.length; i++) {\r\n        let tmpVertexList = []\r\n        tmpVertexList.push(tempVertex[i][0])\r\n        for (let j = 0; j < tempVertex[i].length - 1; j++) {\r\n          let currentVert = tempVertex[i][j]\r\n          let nextVert = tempVertex[i][j + 1]\r\n          let dist = euclidean_distance3D(currentVert, nextVert)\r\n          if (dist > splitDistance) {\r\n            let x = currentVert['x'] + nextVert['x']\r\n            let y = currentVert['y'] + nextVert['y']\r\n            let z = currentVert['z'] + nextVert['z']\r\n            let value = currentVert.value\r\n            tmpVertexList.push({ x: x / 2, y: y / 2, z: z / 2, value: value })\r\n          }\r\n          if (!(dist < removeDistance) || j == tempVertex[i].length - 2) {\r\n            tmpVertexList.push(nextVert)\r\n          }\r\n        }\r\n        tempVertex[i] = tmpVertexList\r\n      }\r\n      subdivision_points_for_edge = tempVertex\r\n    }\r\n\r\n\r\n\r\n    function ComputeSplatting3D() {//流量大于10w按10w算\r\n      let AccMap = []\r\n      for (let i = 0; i < AccResolution * AccResolution * AccResolution; i++) AccMap.push(0)\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let point of line) {\r\n          for (let i = 0; i < KernelSize * KernelSize * KernelSize; i += KernelSize * KernelSize) {\r\n            for (let j = 0; j < KernelSize * KernelSize; j += KernelSize) {\r\n              for (let k = 0; k < KernelSize; k++) {\r\n                //~~运算符：将字符串转成数字\r\n                let x =\r\n                  toInt32(point['x'] * AccResolution) * AccResolution * AccResolution +\r\n                  (~~(i / KernelSize / KernelSize) - ~~(KernelSize / 2)) * AccResolution * AccResolution\r\n                let y =\r\n                  toInt32(point['y'] * AccResolution) * AccResolution + (~~(j / KernelSize) - ~~(KernelSize / 2)) * AccResolution\r\n                //j - ~~(KernelSize / 2)\r\n                let z =\r\n                  toInt32(point['z'] * AccResolution) + (~~(k) - ~~(KernelSize / 2))\r\n                if (x > 0 && x < AccMap.length && y > 0 && y < AccResolution * AccResolution && z > 0 && z < AccResolution) {\r\n                  AccMap[x + y + z] += Kernel[i + j + k] * point.value\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      SplattedAccMap = AccMap\r\n    }\r\n\r\n    //GradientW:15  attractionFactor:1.0    \r\n    function ApplyGradient3D(GradientW, attractionFactor, SplattedAccMap) {\r\n      let kk = 0\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let j = 1; j < line.length - 1; j++) {\r\n          let pointIndex =\r\n            toInt32(line[j]['x'] * AccResolution) * AccResolution * AccResolution +\r\n            toInt32(line[j]['y'] * AccResolution) * AccResolution +\r\n            toInt32(line[j]['z'] * AccResolution)\r\n\r\n\r\n          let localGradient = GetLocalGradient3D(\r\n            GradientW,\r\n            SplattedAccMap,\r\n            line[j],\r\n            pointIndex\r\n          )\r\n          if (localGradient[0] != 0 || localGradient[1] != 0 || localGradient[2] != 0)\r\n            localGradient = gradientNormalize3D(localGradient)\r\n          line[j]['x'] =\r\n            line[j]['x'] + (attractionFactor * localGradient[0]) / AccResolution\r\n          line[j]['y'] =\r\n            line[j]['y'] + (attractionFactor * localGradient[1]) / AccResolution\r\n          line[j]['z'] =\r\n            line[j]['z'] + (attractionFactor * localGradient[2]) / AccResolution\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    function GetLocalGradient3D(gradientW, AccMap, point, pointIndex) {\r\n      let localGradient1 = 0\r\n      let localGradient2 = 0\r\n      let localGradient3 = 0\r\n\r\n\r\n      for (let i = 0; i < gradientW; i++) {\r\n        for (let j = 0; j < gradientW; j++) {\r\n          for (let k = 0; k < gradientW; k++) {\r\n            let offsetIndex =\r\n              (i - ~~(GradientW / 2)) * AccResolution * AccResolution + (j - ~~(GradientW / 2)) * AccResolution + (k - ~~(GradientW / 2))\r\n\r\n            if (\r\n              ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) > 0 &&\r\n              ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) < AccResolution &&\r\n              ~~(((pointIndex + offsetIndex) - ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) * AccResolution * AccResolution) / AccResolution) > 0 &&\r\n              ~~(((pointIndex + offsetIndex) - ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) * AccResolution * AccResolution) / AccResolution) < AccResolution &&\r\n              (pointIndex + offsetIndex) % AccResolution > 0 &&\r\n              (pointIndex + offsetIndex) % AccResolution < AccResolution\r\n            ) {\r\n              let localDensity = AccMap[pointIndex + offsetIndex]\r\n              let dX = i - ~~(GradientW / 2)\r\n              let dY = j - ~~(GradientW / 2)\r\n              let dZ = k - ~~(GradientW / 2)\r\n              localGradient1 += localDensity * dX\r\n              localGradient2 += localDensity * dY\r\n              localGradient3 += localDensity * dZ\r\n\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return [localGradient1, localGradient2, localGradient3]\r\n    }\r\n\r\n\r\n    function gradientNormalize3D(localGradient) {\r\n      let x = localGradient[0]\r\n      let y = localGradient[1]\r\n      let z = localGradient[2]\r\n      let l = Math.sqrt(x * x + y * y + z * z)\r\n      localGradient[0] = x / l\r\n      localGradient[1] = y / l\r\n      localGradient[2] = z / l\r\n      return localGradient\r\n    }\r\n    function SmoothTrajectories3D() {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let i = 1; i < line.length - 1; i++) {\r\n          line[i]['x'] =\r\n            (line[i - 1]['x'] + line[i]['x'] + line[i + 1]['x']) / 3\r\n          line[i]['y'] =\r\n            (line[i - 1]['y'] + line[i]['y'] + line[i + 1]['y']) / 3\r\n          line[i]['z'] =\r\n            (line[i - 1]['z'] + line[i]['z'] + line[i + 1]['z']) / 3\r\n        }\r\n      }\r\n    }\r\n    /*** ********************** ***/\r\n\r\n    /*** Getters/Setters Methods ***/\r\n    forcebundle.nodes = function (nl) {\r\n      if (arguments.length === 0) {\r\n        return data_nodes\r\n      } else {\r\n        data_nodes = nl\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.edges = function (ll) {\r\n      if (arguments.length === 0) {\r\n        return data_edges\r\n      } else {\r\n        data_edges = filter_self_loops(ll) //remove edges to from to the same point\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.splitDis = function (i) {\r\n      if (arguments.length === 0) {\r\n        return splitDistance\r\n      } else {\r\n        splitDistance = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.removeDis = function (i) {\r\n      if (arguments.length === 0) {\r\n        return removeDistance\r\n      } else {\r\n        removeDistance = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.resolution = function (i) {\r\n      if (arguments.length === 0) {\r\n        return AccResolution\r\n      } else {\r\n        AccResolution = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.kernelSize = function (i) {\r\n      if (arguments.length === 0) {\r\n        return KernelSize\r\n      } else {\r\n        KernelSize = i\r\n        Kernel = getKernel3D(KernelSize)\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.gradientW = function (i) {\r\n      if (arguments.length === 0) {\r\n        return GradientW\r\n      } else {\r\n        GradientW = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.attract = function (i) {\r\n      if (arguments.length === 0) {\r\n        return attractionFactor\r\n      } else {\r\n        attractionFactor = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.iteration = function (i) {\r\n      if (arguments.length === 0) {\r\n        return iteration\r\n      } else {\r\n        iteration = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.autoAdapt = function (i) {\r\n      if (arguments.length === 0) {\r\n        return auto_adaption\r\n      } else {\r\n        auto_adaption = i\r\n      }\r\n      return forcebundle\r\n    }\r\n    /*** ************************ ***/\r\n    return forcebundle\r\n  }\r\n\r\n  static KernelEdgeBundling2D() {\r\n    var data_nodes = {}, // {'nodeid':{'x':,'y':},..}\r\n      data_edges = [], // [{'source':'nodeid1', 'target':'nodeid2'},..]\r\n      SplattedAccMap = [],\r\n      subdivision_points_for_edge = [],\r\n      splitDistance = 0.01, // 增大或减小, 都会变松. 增大会稍微平滑一点.\r\n      removeDistance = 0.006, // 增大或减小, 都会变松. 增大会平滑些.\r\n      AccResolution = 100, // 增大, 股数变多. 减小, 股数变小.\r\n      KernelSize = 15, // 增大, 变松. 减小, 变紧. 默认15, 设为20会平滑一些\r\n      Kernel = getKernel(KernelSize),\r\n      GradientW = 15, // 增大, 变松. 减小, 变紧.\r\n      attractionFactor = 1.0, // 增大, 变紧. 减小, 变松\r\n      iteration = iteration2D,//10,//20\r\n      minn = 100000000000000000,\r\n      maxn = -10000,\r\n      xMin = 100000,\r\n      xMax = -100000,\r\n      yMin = 1000000,\r\n      yMax = -1000000,\r\n      auto_adaption = false\r\n\r\n    /*** Helper Methods ***/\r\n    function filter_self_loops(edgelist) {//删掉了自环的边\r\n      var filtered_edge_list = []\r\n      for (var e = 0; e < edgelist.length; e++) {\r\n        if (\r\n          data_nodes[edgelist[e].source].x !=\r\n          data_nodes[edgelist[e].target].x ||\r\n          data_nodes[edgelist[e].source].y != data_nodes[edgelist[e].target].y\r\n        ) {\r\n          //or smaller than eps\r\n          filtered_edge_list.push(edgelist[e])\r\n        }\r\n      }\r\n\r\n      return filtered_edge_list\r\n    }\r\n\r\n    function euclidean_distance(p, q) {\r\n      return Math.sqrt(Math.pow(p.x - q.x, 2) + Math.pow(p.y - q.y, 2))\r\n    }\r\n\r\n    function toInt32(x) {\r\n      /*** C# convert.ToInt32 ***/\r\n      function help(x) {\r\n        let i = Math.floor(x)\r\n        let j = i + 1\r\n        let z = Math.round(x)\r\n        if (x == (i + j) / 2) {\r\n          if (i % 2 == 0) return i\r\n          return j\r\n        }\r\n        return z\r\n      }\r\n      if (x >= 0) return help(x)\r\n      else {\r\n        x = -x\r\n        return -help(x)\r\n      }\r\n    }\r\n    /*** ********************** ***/\r\n\r\n    /*** Initialization Methods ***/\r\n    function getKernel(KernSize) {\r\n      let Kernel = []\r\n      for (let i = 0; i < KernSize * KernSize; i++) Kernel.push(0)\r\n      for (let i = 0; i < KernSize * KernSize; i += KernSize) {\r\n        for (let j = 0; j < KernSize; j++) {\r\n          let temp1 = j - (KernSize - 1) / 2\r\n          let temp2 = i / KernSize - (KernSize - 1) / 2\r\n          let centerDist = Math.sqrt(temp1 * temp1 + temp2 * temp2)\r\n          Kernel[i + j] = Math.max(\r\n            0,\r\n            1 - Math.abs((2 / (KernSize - 1)) * centerDist)\r\n          )\r\n        }\r\n      }\r\n      return Kernel\r\n    }\r\n\r\n    function NodeNormalize() {\r\n      for (var key in data_nodes) {\r\n        var item = data_nodes[key]\r\n        xMin = Math.min(xMin, item.x)\r\n        xMax = Math.max(xMax, item.x)\r\n\r\n        yMin = Math.min(yMin, item.y)\r\n        yMax = Math.max(yMax, item.y)\r\n      }\r\n    }\r\n\r\n    function antiNormalize() {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let point of line) {\r\n          point.x = point.x * (xMax - xMin) + xMin\r\n          point.y = point.y * (yMax - yMin) + yMin\r\n        }\r\n      }\r\n    }\r\n    function initialize_edge_subdivisions() {\r\n      for (var i = 0; i < data_edges.length; i++) {\r\n        subdivision_points_for_edge[i] = []\r\n        subdivision_points_for_edge[i].push({\r\n          id: data_edges[i].source,\r\n          x: (data_nodes[data_edges[i].source].x - xMin) / (xMax - xMin),\r\n          y: (data_nodes[data_edges[i].source].y - yMin) / (yMax - yMin),\r\n          value: data_edges[i].value,\r\n        })\r\n\r\n        subdivision_points_for_edge[i].push({\r\n          id: data_edges[i].target,\r\n          x: (data_nodes[data_edges[i].target].x - xMin) / (xMax - xMin),\r\n          y: (data_nodes[data_edges[i].target].y - yMin) / (yMax - yMin),\r\n          value: data_edges[i].value,\r\n        })\r\n      }\r\n    }\r\n    /*** ********************** ***/\r\n    //格式化流量，大于10W的流量按10W处理\r\n    var initializeBytes = function () {\r\n      data_edges.forEach(edge => {\r\n        //if(edge.value>100000)edge.value = 100000\r\n      })\r\n    }\r\n    /*** Main Bundling Loop Methods ***/\r\n    var forcebundle = function () {\r\n      NodeNormalize()\r\n      initialize_edge_subdivisions()\r\n      initializeBytes()\r\n      for (let i = 0; i < iteration; i++) {\r\n        if (auto_adaption == true && i == ~~(iteration * 0.6)) {\r\n          AccResolution = AccResolution * 2\r\n          KernelSize = KernelSize - 2\r\n          Kernel = getKernel(KernelSize)\r\n        }\r\n        bundle()\r\n      }\r\n      antiNormalize()\r\n      return subdivision_points_for_edge\r\n    }\r\n    /*** ************************ ***/\r\n\r\n    /*** Force Calculation Methods ***/\r\n    function bundle() {\r\n      Resample(splitDistance, removeDistance)//0.01  0.06\r\n      // Splatting\r\n      ComputeSplatting()\r\n      // // Apply Gradient\r\n      ApplyGradient(GradientW, attractionFactor, SplattedAccMap)\r\n      // Smooth trajectories\r\n      for (let i = 0; i < 20; i++) {\r\n        SmoothTrajectories()\r\n      }\r\n\r\n    }\r\n\r\n    function Resample() {\r\n      let tempVertex = subdivision_points_for_edge\r\n      for (let i = 0; i < tempVertex.length; i++) {\r\n        let tmpVertexList = []\r\n        tmpVertexList.push(tempVertex[i][0])\r\n        for (let j = 0; j < tempVertex[i].length - 1; j++) {\r\n          let currentVert = tempVertex[i][j]\r\n          let nextVert = tempVertex[i][j + 1]\r\n          let dist = euclidean_distance(currentVert, nextVert)\r\n          if (dist > splitDistance) {\r\n            let x = currentVert['x'] + nextVert['x']\r\n            let y = currentVert['y'] + nextVert['y']\r\n            let value = currentVert.value\r\n            tmpVertexList.push({ x: x / 2, y: y / 2, value: value })\r\n          }\r\n          if (!(dist < removeDistance) || j == tempVertex[i].length - 2) {\r\n            tmpVertexList.push(nextVert)\r\n          }\r\n        }\r\n        tempVertex[i] = tmpVertexList\r\n      }\r\n      subdivision_points_for_edge = tempVertex\r\n    }\r\n    let mmm = 1\r\n    function ComputeSplatting() {//流量大于10w按10w算\r\n      let AccMap = []\r\n      for (let i = 0; i < AccResolution * AccResolution; i++) AccMap.push(0)\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let point of line) {\r\n          for (let i = 0; i < Kernel.length; i += KernelSize) {\r\n\r\n            for (let j = 0; j < KernelSize; j++) {\r\n              let x =\r\n                toInt32(point['x'] * AccResolution) * AccResolution +\r\n                (~~(i / KernelSize) - ~~(KernelSize / 2)) * AccResolution\r\n              let y =\r\n                toInt32(point['y'] * AccResolution) + j - ~~(KernelSize / 2)\r\n              if (x > 0 && x < AccMap.length && y > 0 && y < AccResolution) {\r\n\r\n                AccMap[x + y] += Kernel[i + j] * point.value\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      SplattedAccMap = AccMap\r\n    }\r\n    function ApplyGradient(GradientW, attractionFactor, SplattedAccMap) {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let j = 1; j < line.length - 1; j++) {\r\n          let pointIndex =\r\n            toInt32(line[j]['x'] * AccResolution) * AccResolution +\r\n            toInt32(line[j]['y'] * AccResolution)\r\n          let localGradient = GetLocalGradient(\r\n            GradientW,\r\n            SplattedAccMap,\r\n            line[j],\r\n            pointIndex\r\n          )\r\n          if (localGradient[0] != 0 || localGradient[1] != 0)\r\n            localGradient = gradientNormalize(localGradient)\r\n          line[j]['x'] =\r\n            line[j]['x'] + (attractionFactor * localGradient[0]) / AccResolution\r\n          line[j]['y'] =\r\n            line[j]['y'] + (attractionFactor * localGradient[1]) / AccResolution\r\n        }\r\n      }\r\n    }\r\n    function GetLocalGradient(gradientW, AccMap, point, pointIndex) {\r\n      let localGradient1 = 0\r\n      let localGradient2 = 0\r\n\r\n      for (let i = 0; i < gradientW; i++) {\r\n        for (let j = 0; j < gradientW; j++) {\r\n          let offsetIndex =\r\n            (i - ~~(GradientW / 2)) * AccResolution + j - ~~(GradientW / 2)\r\n          if (\r\n            ~~((pointIndex + offsetIndex) / AccResolution) > 0 &&\r\n            ~~((pointIndex + offsetIndex) / AccResolution) < AccResolution &&\r\n            (pointIndex + offsetIndex) % AccResolution > 0 &&\r\n            (pointIndex + offsetIndex) % AccResolution < AccResolution\r\n          ) {\r\n            let localDensity = AccMap[pointIndex + offsetIndex]\r\n            let dX = i - ~~(GradientW / 2)\r\n            let dY = j - ~~(GradientW / 2)\r\n            localGradient1 += localDensity * dX\r\n            localGradient2 += localDensity * dY\r\n          }\r\n        }\r\n      }\r\n      return [localGradient1, localGradient2]\r\n    }\r\n\r\n    function gradientNormalize(localGradient) {\r\n      let x = localGradient[0]\r\n      let y = localGradient[1]\r\n      let l = Math.sqrt(x * x + y * y)\r\n      localGradient[0] = x / l\r\n      localGradient[1] = y / l\r\n      return localGradient\r\n    }\r\n\r\n    function SmoothTrajectories() {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let i = 1; i < line.length - 1; i++) {\r\n          line[i]['x'] =\r\n            (line[i - 1]['x'] + line[i]['x'] + line[i + 1]['x']) / 3\r\n          line[i]['y'] =\r\n            (line[i - 1]['y'] + line[i]['y'] + line[i + 1]['y']) / 3\r\n        }\r\n      }\r\n    }\r\n    /*** ********************** ***/\r\n\r\n    /*** Getters/Setters Methods ***/\r\n    forcebundle.nodes = function (nl) {\r\n      if (arguments.length === 0) {\r\n        return data_nodes\r\n      } else {\r\n        data_nodes = nl\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.edges = function (ll) {\r\n      if (arguments.length === 0) {\r\n        return data_edges\r\n      } else {\r\n        data_edges = filter_self_loops(ll) //remove edges to from to the same point\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.splitDis = function (i) {\r\n      if (arguments.length === 0) {\r\n        return splitDistance\r\n      } else {\r\n        splitDistance = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.removeDis = function (i) {\r\n      if (arguments.length === 0) {\r\n        return removeDistance\r\n      } else {\r\n        removeDistance = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.resolution = function (i) {\r\n      if (arguments.length === 0) {\r\n        return AccResolution\r\n      } else {\r\n        AccResolution = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.kernelSize = function (i) {\r\n      if (arguments.length === 0) {\r\n        return KernelSize\r\n      } else {\r\n        KernelSize = i\r\n        Kernel = getKernel(KernelSize)\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.gradientW = function (i) {\r\n      if (arguments.length === 0) {\r\n        return GradientW\r\n      } else {\r\n        GradientW = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.attract = function (i) {\r\n      if (arguments.length === 0) {\r\n        return attractionFactor\r\n      } else {\r\n        attractionFactor = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.iteration = function (i) {\r\n      if (arguments.length === 0) {\r\n        return iteration\r\n      } else {\r\n        iteration = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.autoAdapt = function (i) {\r\n      if (arguments.length === 0) {\r\n        return auto_adaption\r\n      } else {\r\n        auto_adaption = i\r\n      }\r\n      return forcebundle\r\n    }\r\n    /*** ************************ ***/\r\n    return forcebundle\r\n  }\r\n\r\n  static KernelEdgeBundling3D_addLength() {\r\n    var data_nodes = {}, // {'nodeid':{'x':,'y':},..}\r\n      data_edges = [], // [{'source':'nodeid1', 'target':'nodeid2'},..]\r\n      SplattedAccMap = [],\r\n      subdivision_points_for_edge = [],\r\n      splitDistance = 0.01, // 增大或减小, 都会变松. 增大会稍微平滑一点.\r\n      removeDistance = 0.006, // 增大或减小, 都会变松. 增大会平滑些.\r\n      AccResolution = 100, // 增大, 股数变多. 减小, 股数变小.\r\n      KernelSize = 5, // 增大, 变松. 减小, 变紧. 默认15, 设为20会平滑一些\r\n      Kernel = getKernel3D(KernelSize),\r\n      GradientW = 10, // 增大, 变松. 减小, 变紧.10\r\n      attractionFactor = 2.0, // 增大, 变紧. 减小, 变松\r\n      iteration = iteration3D,//10,//20\r\n\r\n      SplattedAccMap2 = [],\r\n      Kernel2 = getKernel3D(KernelSize),\r\n\r\n      firstGradient = [],\r\n      isFirst = true,\r\n\r\n      minn = 100000000000000000,\r\n      maxn = -10000,\r\n      xMin = 100000,\r\n      xMax = -100000,\r\n      yMin = 1000000,\r\n      yMax = -1000000,\r\n\r\n      zMin = 1000000,\r\n      zMax = -1000000,\r\n\r\n      auto_adaption = false\r\n\r\n    /*** Helper Methods ***/\r\n    function filter_self_loops(edgelist) {//删掉自环的边\r\n      var filtered_edge_list = []\r\n      for (var e = 0; e < edgelist.length; e++) {\r\n        if (\r\n          data_nodes[edgelist[e].source].x !=\r\n          data_nodes[edgelist[e].target].x ||\r\n          data_nodes[edgelist[e].source].y != data_nodes[edgelist[e].target].y ||\r\n          data_nodes[edgelist[e].source].z != data_nodes[edgelist[e].target].z\r\n        ) {\r\n          //or smaller than eps\r\n          filtered_edge_list.push(edgelist[e])\r\n        }\r\n      }\r\n\r\n      return filtered_edge_list\r\n    }\r\n\r\n\r\n    function euclidean_distance3D(p, q) {\r\n      return Math.sqrt(Math.pow(p.x - q.x, 2) + Math.pow(p.y - q.y, 2) + Math.pow(p.z - q.z, 2))\r\n    }\r\n\r\n    function toInt32(x) {\r\n      /*** C# convert.ToInt32 ***/\r\n      function help(x) {\r\n        let i = Math.floor(x)\r\n        let j = i + 1\r\n        let z = Math.round(x)\r\n        if (x == (i + j) / 2) {\r\n          if (i % 2 == 0) return i\r\n          return j\r\n        }\r\n        return z\r\n      }\r\n      if (x >= 0) return help(x)\r\n      else {\r\n        x = -x\r\n        return -help(x)\r\n      }\r\n    }\r\n    /*** ********************** ***/\r\n\r\n    /*** Initialization Methods ***/\r\n    function getKernel3D(KernSize) {//初始化kernel\r\n      let Kernel = []\r\n      for (let i = 0; i < KernSize * KernSize * KernSize; i++) Kernel.push(0)\r\n      for (let i = 0; i < KernSize * KernSize * KernSize; i += KernSize * KernSize) {\r\n        for (let j = 0; j < KernSize * KernSize; j += KernSize) {\r\n          for (let k = 0; k < KernSize; k++) {\r\n            let temp1 = k - (KernSize - 1) / 2\r\n            let temp2 = j / KernSize - (KernSize - 1) / 2\r\n            let temp3 = i / KernSize / KernSize - (KernSize - 1) / 2\r\n            let centerDist = Math.sqrt(temp1 * temp1 + temp2 * temp2 + temp3 * temp3)\r\n            Kernel[i + j + k] = Math.max(\r\n              0,\r\n              1 - Math.abs((2 / (KernSize - 1)) * centerDist)\r\n            )\r\n          }\r\n        }\r\n      }\r\n      return Kernel\r\n    }\r\n\r\n\r\n    function NodeNormalize3D() {//求节点的边缘位置，也就是boundingbox\r\n      for (var key in data_nodes) {\r\n        var item = data_nodes[key]\r\n        xMin = Math.min(xMin, item.x)\r\n        xMax = Math.max(xMax, item.x)\r\n\r\n        yMin = Math.min(yMin, item.y)\r\n        yMax = Math.max(yMax, item.y)\r\n\r\n        zMin = Math.min(zMin, item.z)\r\n        zMax = Math.max(zMax, item.z)\r\n      }\r\n    }\r\n\r\n\r\n    function antiNormalize3D() {//反归一化，恢复正常值\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let point of line) {\r\n          point.x = point.x * (xMax - xMin) + xMin\r\n          point.y = point.y * (yMax - yMin) + yMin\r\n          point.z = point.z * (zMax - zMin) + zMin\r\n        }\r\n      }\r\n    }\r\n\r\n    //先把边拆分成path，一个初始点，一个终止点。并且对边的坐标进行归一化，把所有边和节点映射到一个1*1*1的立方体中\r\n    function initialize_edge_subdivisions3D() {\r\n      for (var i = 0; i < data_edges.length; i++) {\r\n        subdivision_points_for_edge[i] = []\r\n        subdivision_points_for_edge[i].push({\r\n          id: data_edges[i].source,\r\n          x: (data_nodes[data_edges[i].source].x - xMin) / (xMax - xMin),\r\n          y: (data_nodes[data_edges[i].source].y - yMin) / (yMax - yMin),\r\n          z: (data_nodes[data_edges[i].source].z - zMin) / (zMax - zMin),\r\n          value: data_edges[i].value,\r\n        })\r\n\r\n        subdivision_points_for_edge[i].push({\r\n          id: data_edges[i].target,\r\n          x: (data_nodes[data_edges[i].target].x - xMin) / (xMax - xMin),\r\n          y: (data_nodes[data_edges[i].target].y - yMin) / (yMax - yMin),\r\n          z: (data_nodes[data_edges[i].target].z - zMin) / (zMax - zMin),\r\n          value: data_edges[i].value,\r\n        })\r\n      }\r\n    }\r\n\r\n    /*** Main Bundling Loop Methods ***/\r\n    var forcebundle = function () {\r\n\r\n      NodeNormalize3D()//求节点的边缘位置，也就是boundingbox\r\n\r\n      initialize_edge_subdivisions3D()//先把边拆分成path，一个初始点，一个终止点。并且对边的坐标进行归一化，把所有边和节点映射到一个1*1*1的立方体中\r\n\r\n      for (let i = 0; i < iteration; i++) {//开始迭代\r\n        if (auto_adaption == true && i == ~~(iteration * 0.6)) {\r\n          AccResolution = AccResolution * 2\r\n          KernelSize = KernelSize - 2\r\n\r\n          Kernel = getKernel3D(KernelSize)\r\n\r\n        }\r\n        bundle3D()//进行绑定\r\n\r\n      }\r\n\r\n      antiNormalize3D()//反归一化，也就是从之前归一化的值，恢复成正常值\r\n      return subdivision_points_for_edge\r\n    }\r\n    /*** ************************ ***/\r\n\r\n    /*** Force Calculation Methods ***/\r\n\r\n    function bundle3D() {\r\n\r\n      Resample3D(splitDistance, removeDistance) //对线段进行采样，采取几个点\r\n\r\n      ComputeSplatting3D()\r\n\r\n      // // Apply Gradient\r\n      ApplyGradient3D(GradientW, attractionFactor, SplattedAccMap)\r\n\r\n      // Smooth trajectories\r\n      for (let i = 0; i < 50; i++) {\r\n        SmoothTrajectories3D()\r\n      }\r\n    }\r\n\r\n\r\n    function Resample3D() {//对每一条边进行采样\r\n      let tempVertex = subdivision_points_for_edge\r\n      for (let i = 0; i < tempVertex.length; i++) {\r\n        let tmpVertexList = []\r\n        tmpVertexList.push(tempVertex[i][0])//每条边的起始点\r\n        for (let j = 0; j < tempVertex[i].length - 1; j++) {//对该边的每个点遍历（除了最后一个点）\r\n          let currentVert = tempVertex[i][j]\r\n          let nextVert = tempVertex[i][j + 1]\r\n          let dist = euclidean_distance3D(currentVert, nextVert)//计算当前点和下一个点的欧氏距离\r\n          if (dist > splitDistance) {//如果这个距离大于分割距离，那就取这两点中间点进行再次分割\r\n            let x = currentVert['x'] + nextVert['x']\r\n            let y = currentVert['y'] + nextVert['y']\r\n            let z = currentVert['z'] + nextVert['z']\r\n            let value = currentVert.value\r\n            tmpVertexList.push({ x: x / 2, y: y / 2, z: z / 2, value: value })\r\n          }\r\n          //如果距离大于要求的最小距离，或者当前点是倒数第二个点，那么就把下一个点添加进去\r\n          if (!(dist < removeDistance) || j == tempVertex[i].length - 2) {\r\n            tmpVertexList.push(nextVert)\r\n          }\r\n        }\r\n        tempVertex[i] = tmpVertexList\r\n      }\r\n      subdivision_points_for_edge = tempVertex\r\n    }\r\n\r\n    function Resample3D2() {\r\n      let tempVertex = subdivision_points_for_edge\r\n      for (let i = 0; i < tempVertex.length; i++) {\r\n        let tmpVertexList = []\r\n        tmpVertexList.push(tempVertex[i][0])//每条边的起始点\r\n        for (let j = 0; j < tempVertex[i].length - 1; j++) {//对该边的每个点遍历（除了最后一个点）\r\n          let currentVert = tempVertex[i][j]\r\n          let nextVert = tempVertex[i][j + 1]\r\n          let dist = euclidean_distance3D(currentVert, nextVert)//计算当前点和下一个点的欧氏距离\r\n          if (dist > splitDistance) {//如果这个距离大于分割距离，那就取这两点中间点进行再次分割\r\n            let x = currentVert['x'] + nextVert['x']\r\n            let y = currentVert['y'] + nextVert['y']\r\n            let z = currentVert['z'] + nextVert['z']\r\n            let value = currentVert.value\r\n            tmpVertexList.push({ x: x / 2, y: y / 2, z: z / 2, value: value })\r\n          }\r\n          //如果距离大于要求的最小距离，或者当前点是倒数第二个点，那么就把下一个点添加进去\r\n          if (!(dist < removeDistance) || j == tempVertex[i].length - 2) {\r\n            tmpVertexList.push(nextVert)\r\n          }\r\n        }\r\n        tempVertex[i] = tmpVertexList\r\n      }\r\n      subdivision_points_for_edge = tempVertex\r\n    }\r\n\r\n\r\n\r\n    function ComputeSplatting3D() {//\r\n      let AccMap = []\r\n      let AccMap2 = []\r\n      for (let i = 0; i < AccResolution * AccResolution * AccResolution; i++) {\r\n        AccMap.push(0)\r\n        AccMap2.push(0)\r\n      }\r\n      for (let line of subdivision_points_for_edge) {//计算AccMap的值\r\n        for (let point of line) {\r\n          for (let i = 0; i < KernelSize * KernelSize * KernelSize; i += KernelSize * KernelSize) {\r\n            for (let j = 0; j < KernelSize * KernelSize; j += KernelSize) {\r\n              for (let k = 0; k < KernelSize; k++) {\r\n                //~~运算符：将字符串转成数字\r\n                let x =\r\n                  toInt32(point['x'] * AccResolution) * AccResolution * AccResolution +\r\n                  (~~(i / KernelSize / KernelSize) - ~~(KernelSize / 2)) * AccResolution * AccResolution\r\n                let y =\r\n                  toInt32(point['y'] * AccResolution) * AccResolution + (~~(j / KernelSize) - ~~(KernelSize / 2)) * AccResolution\r\n                //j - ~~(KernelSize / 2)\r\n                let z =\r\n                  toInt32(point['z'] * AccResolution) + (~~(k) - ~~(KernelSize / 2))\r\n                if (x > 0 && x < AccMap.length && y > 0 && y < AccResolution * AccResolution && z > 0 && z < AccResolution) {\r\n                  AccMap[x + y + z] += Kernel[i + j + k] * point.value\r\n                  if (isFirst) AccMap2[x + y + z] += Kernel2[i + j + k]\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      SplattedAccMap = AccMap\r\n      if (isFirst) SplattedAccMap2 = AccMap2\r\n      isFirst = false\r\n    }\r\n\r\n    //GradientW:15  attractionFactor:1.0    \r\n    //SplattedAccMap是所有点的kernel相加之后的AccMap\r\n    function ApplyGradient3D(GradientW, attractionFactor, SplattedAccMap) {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let j = 1; j < line.length - 1; j++) {\r\n          //求这个点所在的AccMap中的位置\r\n          let pointIndex =\r\n            toInt32(line[j]['x'] * AccResolution) * AccResolution * AccResolution +\r\n            toInt32(line[j]['y'] * AccResolution) * AccResolution +\r\n            toInt32(line[j]['z'] * AccResolution)\r\n\r\n\r\n          let localGradient = GetLocalGradient3D(//得到该点附近GradientW立方体大小范围内的 合力\r\n            GradientW,\r\n            SplattedAccMap,\r\n            line[j],\r\n            pointIndex\r\n          )\r\n\r\n          let localGradient2 = GetForceGradient3D(line, line[j])\r\n\r\n          if (localGradient[0] != 0 || localGradient[1] != 0 || localGradient[2] != 0)//合力有一个方向不为0\r\n            localGradient = gradientNormalize3D(localGradient)//对梯度进行归一化\r\n          if (localGradient2[0] != 0 || localGradient2[1] != 0 || localGradient2[2] != 0)//合力有一个方向不为0\r\n            localGradient2 = gradientNormalize3D(localGradient2)//对梯度进行归一化\r\n          // 根据梯度，修改xyz坐标.\r\n          line[j]['x'] =\r\n            line[j]['x'] + (attractionFactor * localGradient[0]) / AccResolution + (attractionFactor * 0.8 * localGradient2[0]) / AccResolution\r\n          line[j]['y'] =\r\n            line[j]['y'] + (attractionFactor * localGradient[1]) / AccResolution + (attractionFactor * 0.8 * localGradient2[1]) / AccResolution\r\n          line[j]['z'] =\r\n            line[j]['z'] + (attractionFactor * localGradient[2]) / AccResolution + (attractionFactor * 0.8 * localGradient2[2]) / AccResolution\r\n        }\r\n      }\r\n    }\r\n\r\n    //gradientW:10, AccMap, pointIndex是当前点在AccMap中的位置\r\n    function GetLocalGradient3D(gradientW, AccMap, point, pointIndex) {\r\n      let localGradient1 = 0\r\n      let localGradient2 = 0\r\n      let localGradient3 = 0\r\n\r\n      //gradientW 和 GradientW是一样的\r\n      for (let i = 0; i < gradientW; i++) {\r\n        for (let j = 0; j < gradientW; j++) {\r\n          for (let k = 0; k < gradientW; k++) {\r\n            let offsetIndex =\r\n              (i - ~~(GradientW / 2)) * AccResolution * AccResolution + (j - ~~(GradientW / 2)) * AccResolution + (k - ~~(GradientW / 2))\r\n\r\n            if (//如果该点的附近gradientW大小的立方体在AccMap内的点，计算合力\r\n              ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) > 0 &&//X轴防止超出Acc最小值边界，因为最小值是0\r\n              ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) < AccResolution &&//x轴防止超出Acc最大值边界\r\n              ~~(((pointIndex + offsetIndex) - ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) * AccResolution * AccResolution) / AccResolution) > 0 &&//y轴\r\n              ~~(((pointIndex + offsetIndex) - ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) * AccResolution * AccResolution) / AccResolution) < AccResolution &&//y轴\r\n              (pointIndex + offsetIndex) % AccResolution > 0 &&//z轴\r\n              (pointIndex + offsetIndex) % AccResolution < AccResolution//z轴\r\n            ) {\r\n              let localDensity = AccMap[pointIndex + offsetIndex]//\r\n              let dX = i - ~~(GradientW / 2)\r\n              let dY = j - ~~(GradientW / 2)\r\n              let dZ = k - ~~(GradientW / 2)\r\n              //三个方向上的合力。\r\n              localGradient1 += localDensity * dX\r\n              localGradient2 += localDensity * dY\r\n              localGradient3 += localDensity * dZ\r\n\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return [localGradient1, localGradient2, localGradient3]\r\n    }\r\n\r\n    function GetForceGradient3D(line, point) {\r\n      let px = point[\"x\"]\r\n      let py = point[\"y\"]\r\n      let pz = point[\"z\"]\r\n\r\n      let startX = line[0][\"x\"]\r\n      let startY = line[0][\"y\"]\r\n      let startZ = line[0][\"z\"]\r\n\r\n      let endX = line[line.length - 1][\"x\"]\r\n      let endY = line[line.length - 1][\"y\"]\r\n      let endZ = line[line.length - 1][\"z\"]\r\n\r\n      let cx = Math.abs((startX - endX) * (endZ - pz) / (endZ - startZ)) + endX\r\n      let cy = Math.abs((startY - endY) * (endZ - pz) / (endZ - startZ)) + endY\r\n      let cz = pz\r\n\r\n      //let dis = Math.sqrt( (px-cx)*(px-cx) +(py-cy)*(py-cy) + (pz-cz)*(pz-cz) )\r\n      let fx = (cx - px)\r\n      let fy = (cy - py)\r\n      let fz = 0\r\n\r\n      return [fx, fy, 0]\r\n    }\r\n\r\n\r\n    function gradientNormalize3D(localGradient) {//归一化梯度\r\n      let x = localGradient[0]\r\n      let y = localGradient[1]\r\n      let z = localGradient[2]\r\n      let l = Math.sqrt(x * x + y * y + z * z)\r\n      localGradient[0] = x / l\r\n      localGradient[1] = y / l\r\n      localGradient[2] = z / l\r\n      return localGradient\r\n    }\r\n    function SmoothTrajectories3D() {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let i = 1; i < line.length - 1; i++) {\r\n          line[i]['x'] =\r\n            (line[i - 1]['x'] + line[i]['x'] + line[i + 1]['x']) / 3\r\n          line[i]['y'] =\r\n            (line[i - 1]['y'] + line[i]['y'] + line[i + 1]['y']) / 3\r\n          line[i]['z'] =\r\n            (line[i - 1]['z'] + line[i]['z'] + line[i + 1]['z']) / 3\r\n        }\r\n      }\r\n    }\r\n    /*** ********************** ***/\r\n\r\n    /*** Getters/Setters Methods ***/\r\n    forcebundle.nodes = function (nl) {\r\n      if (arguments.length === 0) {\r\n        return data_nodes\r\n      } else {\r\n        data_nodes = nl\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.edges = function (ll) {\r\n      if (arguments.length === 0) {\r\n        return data_edges\r\n      } else {\r\n        data_edges = filter_self_loops(ll) //remove edges to from to the same point\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.splitDis = function (i) {\r\n      if (arguments.length === 0) {\r\n        return splitDistance\r\n      } else {\r\n        splitDistance = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.removeDis = function (i) {\r\n      if (arguments.length === 0) {\r\n        return removeDistance\r\n      } else {\r\n        removeDistance = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.resolution = function (i) {\r\n      if (arguments.length === 0) {\r\n        return AccResolution\r\n      } else {\r\n        AccResolution = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.kernelSize = function (i) {\r\n      if (arguments.length === 0) {\r\n        return KernelSize\r\n      } else {\r\n        KernelSize = i\r\n        Kernel = getKernel3D(KernelSize)\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.gradientW = function (i) {\r\n      if (arguments.length === 0) {\r\n        return GradientW\r\n      } else {\r\n        GradientW = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.attract = function (i) {\r\n      if (arguments.length === 0) {\r\n        return attractionFactor\r\n      } else {\r\n        attractionFactor = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.iteration = function (i) {\r\n      if (arguments.length === 0) {\r\n        return iteration\r\n      } else {\r\n        iteration = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.autoAdapt = function (i) {\r\n      if (arguments.length === 0) {\r\n        return auto_adaption\r\n      } else {\r\n        auto_adaption = i\r\n      }\r\n      return forcebundle\r\n    }\r\n    /*** ************************ ***/\r\n    return forcebundle\r\n  }\r\n  static KernelEdgeBundling3D_addSpring() {\r\n    var data_nodes = {}, // {'nodeid':{'x':,'y':},..}\r\n      data_edges = [], // [{'source':'nodeid1', 'target':'nodeid2'},..]\r\n      SplattedAccMap = [],\r\n      subdivision_points_for_edge = [],\r\n      splitDistance = 0.01, // 增大或减小, 都会变松. 增大会稍微平滑一点.\r\n      removeDistance = 0.006, // 增大或减小, 都会变松. 增大会平滑些.\r\n      AccResolution = 100, // 增大, 股数变多. 减小, 股数变小.\r\n      KernelSize = 5, // 增大, 变松. 减小, 变紧. 默认15, 设为20会平滑一些\r\n      Kernel = getKernel3D(KernelSize),\r\n      GradientW = 10, // 增大, 变松. 减小, 变紧.10\r\n      attractionFactor = 2.0, // 增大, 变紧. 减小, 变松\r\n      iteration = iteration3D,//10,//20\r\n\r\n      SplattedAccMap2 = [],\r\n      Kernel2 = getKernel3D(KernelSize),\r\n\r\n      firstGradient = [],\r\n      isFirst = true,\r\n\r\n      minn = 100000000000000000,\r\n      maxn = -10000,\r\n      xMin = 100000,\r\n      xMax = -100000,\r\n      yMin = 1000000,\r\n      yMax = -1000000,\r\n\r\n      zMin = 1000000,\r\n      zMax = -1000000,\r\n\r\n      auto_adaption = false\r\n\r\n    /*** Helper Methods ***/\r\n    function filter_self_loops(edgelist) {//删掉自环的边\r\n      var filtered_edge_list = []\r\n      for (var e = 0; e < edgelist.length; e++) {\r\n        if (\r\n          data_nodes[edgelist[e].source].x !=\r\n          data_nodes[edgelist[e].target].x ||\r\n          data_nodes[edgelist[e].source].y != data_nodes[edgelist[e].target].y ||\r\n          data_nodes[edgelist[e].source].z != data_nodes[edgelist[e].target].z\r\n        ) {\r\n          //or smaller than eps\r\n          filtered_edge_list.push(edgelist[e])\r\n        }\r\n      }\r\n\r\n      return filtered_edge_list\r\n    }\r\n\r\n\r\n    function euclidean_distance3D(p, q) {\r\n      return Math.sqrt(Math.pow(p.x - q.x, 2) + Math.pow(p.y - q.y, 2) + Math.pow(p.z - q.z, 2))\r\n    }\r\n\r\n    function toInt32(x) {\r\n      /*** C# convert.ToInt32 ***/\r\n      function help(x) {\r\n        let i = Math.floor(x)\r\n        let j = i + 1\r\n        let z = Math.round(x)\r\n        if (x == (i + j) / 2) {\r\n          if (i % 2 == 0) return i\r\n          return j\r\n        }\r\n        return z\r\n      }\r\n      if (x >= 0) return help(x)\r\n      else {\r\n        x = -x\r\n        return -help(x)\r\n      }\r\n    }\r\n    /*** ********************** ***/\r\n\r\n    /*** Initialization Methods ***/\r\n    function getKernel3D(KernSize) {//初始化kernel\r\n      let Kernel = []\r\n      for (let i = 0; i < KernSize * KernSize * KernSize; i++) Kernel.push(0)\r\n      for (let i = 0; i < KernSize * KernSize * KernSize; i += KernSize * KernSize) {\r\n        for (let j = 0; j < KernSize * KernSize; j += KernSize) {\r\n          for (let k = 0; k < KernSize; k++) {\r\n            let temp1 = k - (KernSize - 1) / 2\r\n            let temp2 = j / KernSize - (KernSize - 1) / 2\r\n            let temp3 = i / KernSize / KernSize - (KernSize - 1) / 2\r\n            let centerDist = Math.sqrt(temp1 * temp1 + temp2 * temp2 + temp3 * temp3)\r\n            Kernel[i + j + k] = Math.max(\r\n              0,\r\n              1 - Math.abs((2 / (KernSize - 1)) * centerDist)\r\n            )\r\n          }\r\n        }\r\n      }\r\n      return Kernel\r\n    }\r\n\r\n\r\n    function NodeNormalize3D() {//求节点的边缘位置，也就是boundingbox\r\n      for (var key in data_nodes) {\r\n        var item = data_nodes[key]\r\n        xMin = Math.min(xMin, item.x)\r\n        xMax = Math.max(xMax, item.x)\r\n\r\n        yMin = Math.min(yMin, item.y)\r\n        yMax = Math.max(yMax, item.y)\r\n\r\n        zMin = Math.min(zMin, item.z)\r\n        zMax = Math.max(zMax, item.z)\r\n      }\r\n    }\r\n\r\n\r\n    function antiNormalize3D() {//反归一化，恢复正常值\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let point of line) {\r\n          point.x = point.x * (xMax - xMin) + xMin\r\n          point.y = point.y * (yMax - yMin) + yMin\r\n          point.z = point.z * (zMax - zMin) + zMin\r\n        }\r\n      }\r\n    }\r\n\r\n    //先把边拆分成path，一个初始点，一个终止点。并且对边的坐标进行归一化，把所有边和节点映射到一个1*1*1的立方体中\r\n    function initialize_edge_subdivisions3D() {\r\n      for (var i = 0; i < data_edges.length; i++) {\r\n        subdivision_points_for_edge[i] = []\r\n        subdivision_points_for_edge[i].push({\r\n          id: data_edges[i].source,\r\n          x: (data_nodes[data_edges[i].source].x - xMin) / (xMax - xMin),\r\n          y: (data_nodes[data_edges[i].source].y - yMin) / (yMax - yMin),\r\n          z: (data_nodes[data_edges[i].source].z - zMin) / (zMax - zMin),\r\n          value: data_edges[i].value,\r\n        })\r\n\r\n        subdivision_points_for_edge[i].push({\r\n          id: data_edges[i].target,\r\n          x: (data_nodes[data_edges[i].target].x - xMin) / (xMax - xMin),\r\n          y: (data_nodes[data_edges[i].target].y - yMin) / (yMax - yMin),\r\n          z: (data_nodes[data_edges[i].target].z - zMin) / (zMax - zMin),\r\n          value: data_edges[i].value,\r\n        })\r\n      }\r\n    }\r\n\r\n    /*** Main Bundling Loop Methods ***/\r\n    var forcebundle = function () {\r\n\r\n      NodeNormalize3D()//求节点的边缘位置，也就是boundingbox\r\n\r\n      initialize_edge_subdivisions3D()//先把边拆分成path，一个初始点，一个终止点。并且对边的坐标进行归一化，把所有边和节点映射到一个1*1*1的立方体中\r\n\r\n      Resample3D()\r\n      for (let i = 0; i < iteration; i++) {//开始迭代\r\n        if (auto_adaption == true && i == ~~(iteration * 0.6)) {\r\n          AccResolution = AccResolution * 2\r\n          KernelSize = KernelSize - 2\r\n\r\n          Kernel = getKernel3D(KernelSize)\r\n\r\n        }\r\n        bundle3D()//进行绑定\r\n\r\n      }\r\n\r\n      antiNormalize3D()//反归一化，也就是从之前归一化的值，恢复成正常值\r\n      return subdivision_points_for_edge\r\n    }\r\n    /*** ************************ ***/\r\n\r\n    /*** Force Calculation Methods ***/\r\n\r\n    function bundle3D() {\r\n\r\n      //Resample3D(splitDistance, removeDistance) //对线段进行采样，采取几个点\r\n\r\n      ComputeSplatting3D()\r\n\r\n      // // Apply Gradient\r\n      ApplyGradient3D(GradientW, attractionFactor, SplattedAccMap)\r\n\r\n      // Smooth trajectories\r\n      for (let i = 0; i < 50; i++) {\r\n        SmoothTrajectories3D()\r\n      }\r\n    }\r\n\r\n\r\n    function Resample3D() {//对每一条边进行采样\r\n      let tempVertex = subdivision_points_for_edge\r\n      let statistics = {}\r\n      for (let i = 0; i < tempVertex.length; i++) {\r\n        let tmpVertexList = []\r\n        tmpVertexList.push(tempVertex[i][0])//每条边的起始点\r\n        let startX = tempVertex[i][0][\"x\"]\r\n        let startY = tempVertex[i][0][\"y\"]\r\n        let startZ = tempVertex[i][0][\"z\"]\r\n\r\n        let endX = tempVertex[i][tempVertex[i].length - 1][\"x\"]\r\n        let endY = tempVertex[i][tempVertex[i].length - 1][\"y\"]\r\n        let endZ = tempVertex[i][tempVertex[i].length - 1][\"z\"]\r\n\r\n        let value = tempVertex[i][0][\"value\"]\r\n\r\n        let dist = Math.sqrt((endX - startX) * (endX - startX) + (endY - startY) * (endY - startY) + (endZ - startZ) * (endZ - startZ))\r\n        let minDist = 0.01\r\n        let num = 0\r\n        for (let k = 1; true; k++) {\r\n          let nx = (endX - startX) * (k * minDist / dist) + startX\r\n          let ny = (endY - startY) * (k * minDist / dist) + startY\r\n          let nz = (endZ - startZ) * (k * minDist / dist) + startZ\r\n\r\n          num++\r\n\r\n          if ((nx - startX) * (nx - endX) >= 0) {\r\n            tmpVertexList.push(tempVertex[i][tempVertex[i].length - 1])\r\n            statistics[num] = statistics[num] === undefined ? 1 : statistics[num] + 1\r\n            break\r\n          } else {\r\n            tmpVertexList.push({ x: nx, y: ny, z: nz, value: value })\r\n          }\r\n        }\r\n        tempVertex[i] = tmpVertexList\r\n      }\r\n\r\n      console.log(\"采样点的个数为：\", statistics)\r\n      subdivision_points_for_edge = tempVertex\r\n    }\r\n\r\n    function Resample3D2() {\r\n      let tempVertex = subdivision_points_for_edge\r\n      for (let i = 0; i < tempVertex.length; i++) {\r\n        let tmpVertexList = []\r\n        tmpVertexList.push(tempVertex[i][0])//每条边的起始点\r\n        for (let j = 0; j < tempVertex[i].length - 1; j++) {//对该边的每个点遍历（除了最后一个点）\r\n          let currentVert = tempVertex[i][j]\r\n          let nextVert = tempVertex[i][j + 1]\r\n          let dist = euclidean_distance3D(currentVert, nextVert)//计算当前点和下一个点的欧氏距离\r\n          if (dist > splitDistance) {//如果这个距离大于分割距离，那就取这两点中间点进行再次分割\r\n            let x = currentVert['x'] + nextVert['x']\r\n            let y = currentVert['y'] + nextVert['y']\r\n            let z = currentVert['z'] + nextVert['z']\r\n            let value = currentVert.value\r\n            tmpVertexList.push({ x: x / 2, y: y / 2, z: z / 2, value: value })\r\n          }\r\n          //如果距离大于要求的最小距离，或者当前点是倒数第二个点，那么就把下一个点添加进去\r\n          if (!(dist < removeDistance) || j == tempVertex[i].length - 2) {\r\n            tmpVertexList.push(nextVert)\r\n          }\r\n        }\r\n        tempVertex[i] = tmpVertexList\r\n      }\r\n      subdivision_points_for_edge = tempVertex\r\n    }\r\n\r\n\r\n\r\n    function ComputeSplatting3D() {//\r\n      let AccMap = []\r\n      let AccMap2 = []\r\n      for (let i = 0; i < AccResolution * AccResolution * AccResolution; i++) {\r\n        AccMap.push(0)\r\n        AccMap2.push(0)\r\n      }\r\n      for (let line of subdivision_points_for_edge) {//计算AccMap的值\r\n        for (let point of line) {\r\n          for (let i = 0; i < KernelSize * KernelSize * KernelSize; i += KernelSize * KernelSize) {\r\n            for (let j = 0; j < KernelSize * KernelSize; j += KernelSize) {\r\n              for (let k = 0; k < KernelSize; k++) {\r\n                //~~运算符：将字符串转成数字\r\n                let x =\r\n                  toInt32(point['x'] * AccResolution) * AccResolution * AccResolution +\r\n                  (~~(i / KernelSize / KernelSize) - ~~(KernelSize / 2)) * AccResolution * AccResolution\r\n                let y =\r\n                  toInt32(point['y'] * AccResolution) * AccResolution + (~~(j / KernelSize) - ~~(KernelSize / 2)) * AccResolution\r\n                //j - ~~(KernelSize / 2)\r\n                let z =\r\n                  toInt32(point['z'] * AccResolution) + (~~(k) - ~~(KernelSize / 2))\r\n                if (x > 0 && x < AccMap.length && y > 0 && y < AccResolution * AccResolution && z > 0 && z < AccResolution) {\r\n                  AccMap[x + y + z] += Kernel[i + j + k] * point.value\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      SplattedAccMap = AccMap\r\n      if (isFirst) SplattedAccMap2 = AccMap2\r\n      isFirst = false\r\n    }\r\n\r\n    let graSum = 0\r\n    //GradientW:15  attractionFactor:1.0    \r\n    //SplattedAccMap是所有点的kernel相加之后的AccMap\r\n    function ApplyGradient3D(GradientW, attractionFactor, SplattedAccMap) {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let j = 1; j < line.length - 1; j++) {\r\n          //求这个点所在的AccMap中的位置\r\n          let pointIndex =\r\n            toInt32(line[j]['x'] * AccResolution) * AccResolution * AccResolution +\r\n            toInt32(line[j]['y'] * AccResolution) * AccResolution +\r\n            toInt32(line[j]['z'] * AccResolution)\r\n\r\n\r\n          let localGradient = GetLocalGradient3D(//得到该点附近GradientW立方体大小范围内的 合力\r\n            GradientW,\r\n            SplattedAccMap,\r\n            line[j],\r\n            pointIndex\r\n          )\r\n\r\n          //let localGradient2 = GetForceGradient3D(line[j-1], line[j], line[j+1])\r\n\r\n          //let {gradient,dist} = GetForceGradient3D_1(line[0], line[j], line[line.length-1])\r\n          let FG1 = GetForceGradient3D_ByNum(j, line, 1)\r\n          let FG2 = GetForceGradient3D_ByNum(j, line, 2)\r\n          let FG3 = GetForceGradient3D_ByNum(j, line, 3)\r\n\r\n          let gradient1 = FG1.gradient, dist1 = FG1.dist\r\n          let gradient2 = FG2.gradient, dist2 = FG2.dist\r\n          let gradient3 = FG3.gradient, dist3 = FG3.dist\r\n\r\n          if (localGradient[0] != 0 || localGradient[1] != 0 || localGradient[2] != 0)//合力有一个方向不为0\r\n            localGradient = gradientNormalize3D(localGradient)//对梯度进行归一化\r\n\r\n          if (gradient1[0] != 0 || gradient1[1] != 0 || gradient1[2] != 0)//合力有一个方向不为0\r\n            gradient1 = gradientNormalize3D(gradient1)//对梯度进行归一化\r\n\r\n          if (gradient2[0] != 0 || gradient2[1] != 0 || gradient2[2] != 0)//合力有一个方向不为0\r\n            gradient2 = gradientNormalize3D(gradient2)//对梯度进行归一化\r\n\r\n          if (gradient3[0] != 0 || gradient3[1] != 0 || gradient3[2] != 0)//合力有一个方向不为0\r\n            gradient3 = gradientNormalize3D(gradient3)//对梯度进行归一化\r\n\r\n          if (graSum < 0) {\r\n            graSum++\r\n            console.log(\"localGradient:\", localGradient)\r\n            console.log(\"FG1\", FG1)\r\n            console.log(\"FG2\", FG2)\r\n            console.log(\"FG3\", FG3)\r\n          }\r\n\r\n          // 根据梯度，修改xyz坐标.\r\n          line[j]['x'] =\r\n            line[j]['x'] + 1 * (attractionFactor * localGradient[0]) / AccResolution\r\n            + (attractionFactor * 6 * gradient1[0]) / AccResolution * dist1\r\n            + (attractionFactor * 3 * gradient2[0]) / AccResolution * dist2\r\n            + (attractionFactor * 1 * gradient3[0]) / AccResolution * dist3\r\n          line[j]['y'] =\r\n            line[j]['y'] + 1 * (attractionFactor * localGradient[1]) / AccResolution\r\n            + (attractionFactor * 6 * gradient1[1]) / AccResolution * dist1\r\n            + (attractionFactor * 3 * gradient2[1]) / AccResolution * dist2\r\n            + (attractionFactor * 1 * gradient3[1]) / AccResolution * dist3\r\n          line[j]['z'] =\r\n            line[j]['z'] + 1 * (attractionFactor * localGradient[2]) / AccResolution\r\n            + (attractionFactor * 6 * gradient1[2]) / AccResolution * dist1\r\n            + (attractionFactor * 3 * gradient2[2]) / AccResolution * dist2\r\n            + (attractionFactor * 1 * gradient3[2]) / AccResolution * dist3\r\n        }\r\n      }\r\n    }\r\n\r\n    //gradientW:10, AccMap, pointIndex是当前点在AccMap中的位置\r\n    function GetLocalGradient3D(gradientW, AccMap, point, pointIndex) {\r\n      let localGradient1 = 0\r\n      let localGradient2 = 0\r\n      let localGradient3 = 0\r\n\r\n      //gradientW 和 GradientW是一样的\r\n      for (let i = 0; i < gradientW; i++) {\r\n        for (let j = 0; j < gradientW; j++) {\r\n          for (let k = 0; k < gradientW; k++) {\r\n            let offsetIndex =\r\n              (i - ~~(GradientW / 2)) * AccResolution * AccResolution + (j - ~~(GradientW / 2)) * AccResolution + (k - ~~(GradientW / 2))\r\n\r\n            if (//如果该点的附近gradientW大小的立方体在AccMap内的点，计算合力\r\n              ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) > 0 &&//X轴防止超出Acc最小值边界，因为最小值是0\r\n              ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) < AccResolution &&//x轴防止超出Acc最大值边界\r\n              ~~(((pointIndex + offsetIndex) - ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) * AccResolution * AccResolution) / AccResolution) > 0 &&//y轴\r\n              ~~(((pointIndex + offsetIndex) - ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) * AccResolution * AccResolution) / AccResolution) < AccResolution &&//y轴\r\n              (pointIndex + offsetIndex) % AccResolution > 0 &&//z轴\r\n              (pointIndex + offsetIndex) % AccResolution < AccResolution//z轴\r\n            ) {\r\n              let localDensity = AccMap[pointIndex + offsetIndex]//\r\n              let dX = i - ~~(GradientW / 2)\r\n              let dY = j - ~~(GradientW / 2)\r\n              let dZ = k - ~~(GradientW / 2)\r\n              //三个方向上的合力。\r\n              localGradient1 += localDensity * dX\r\n              localGradient2 += localDensity * dY\r\n              localGradient3 += localDensity * dZ\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return [localGradient1, localGradient2, localGradient3]\r\n    }\r\n\r\n    function GetForceGradient3D_1(prePoint, curPoint, nexPoint) {\r\n      let cpX = prePoint[\"x\"] - curPoint[\"x\"]\r\n      let cpY = prePoint[\"y\"] - curPoint[\"y\"]\r\n      let cpZ = prePoint[\"z\"] - curPoint[\"z\"]\r\n\r\n      let cnX = nexPoint[\"x\"] - curPoint[\"x\"]\r\n      let cnY = nexPoint[\"y\"] - curPoint[\"y\"]\r\n      let cnZ = nexPoint[\"z\"] - curPoint[\"z\"]\r\n\r\n      let fx = cpX + cnX\r\n      let fy = cpY + cnY\r\n      let fz = cpZ + cnZ\r\n\r\n      let dist = Math.sqrt(fx * fx + fy * fy + fz * fz)\r\n\r\n      return { gradient: [fx, fy, fz], dist }\r\n    }\r\n\r\n    function GetForceGradient3D_ByNum(index, line, power) {\r\n      let max = line.length - 1\r\n      let min = 0\r\n      let preIndex = index - power\r\n      let nexIndex = index + power\r\n      if (preIndex < min || nexIndex > max) return { gradient: [1, 1, 1], dist: 0 }\r\n\r\n      let prePoint = line[preIndex]\r\n      let curPoint = line[index]\r\n      let nexPoint = line[nexIndex]\r\n\r\n      let cpX = prePoint[\"x\"] - curPoint[\"x\"]\r\n      let cpY = prePoint[\"y\"] - curPoint[\"y\"]\r\n      let cpZ = prePoint[\"z\"] - curPoint[\"z\"]\r\n\r\n      let cnX = nexPoint[\"x\"] - curPoint[\"x\"]\r\n      let cnY = nexPoint[\"y\"] - curPoint[\"y\"]\r\n      let cnZ = nexPoint[\"z\"] - curPoint[\"z\"]\r\n\r\n      let fx = cpX + cnX\r\n      let fy = cpY + cnY\r\n      let fz = cpZ + cnZ\r\n      let dist = Math.sqrt(fx * fx + fy * fy + fz * fz)\r\n\r\n      return { gradient: [fx, fy, fz], dist: dist }\r\n    }\r\n\r\n    function gradientNormalize3D(localGradient) {//归一化梯度\r\n      let x = localGradient[0]\r\n      let y = localGradient[1]\r\n      let z = localGradient[2]\r\n      let l = Math.sqrt(x * x + y * y + z * z)\r\n      localGradient[0] = x / l\r\n      localGradient[1] = y / l\r\n      localGradient[2] = z / l\r\n      return localGradient\r\n    }\r\n    function SmoothTrajectories3D() {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let i = 1; i < line.length - 1; i++) {\r\n          line[i]['x'] =\r\n            (line[i - 1]['x'] + line[i]['x'] + line[i + 1]['x']) / 3\r\n          line[i]['y'] =\r\n            (line[i - 1]['y'] + line[i]['y'] + line[i + 1]['y']) / 3\r\n          line[i]['z'] =\r\n            (line[i - 1]['z'] + line[i]['z'] + line[i + 1]['z']) / 3\r\n        }\r\n      }\r\n    }\r\n    /*** ********************** ***/\r\n\r\n    /*** Getters/Setters Methods ***/\r\n    forcebundle.nodes = function (nl) {\r\n      if (arguments.length === 0) {\r\n        return data_nodes\r\n      } else {\r\n        data_nodes = nl\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.edges = function (ll) {\r\n      if (arguments.length === 0) {\r\n        return data_edges\r\n      } else {\r\n        data_edges = filter_self_loops(ll) //remove edges to from to the same point\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.splitDis = function (i) {\r\n      if (arguments.length === 0) {\r\n        return splitDistance\r\n      } else {\r\n        splitDistance = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.removeDis = function (i) {\r\n      if (arguments.length === 0) {\r\n        return removeDistance\r\n      } else {\r\n        removeDistance = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.resolution = function (i) {\r\n      if (arguments.length === 0) {\r\n        return AccResolution\r\n      } else {\r\n        AccResolution = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.kernelSize = function (i) {\r\n      if (arguments.length === 0) {\r\n        return KernelSize\r\n      } else {\r\n        KernelSize = i\r\n        Kernel = getKernel3D(KernelSize)\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.gradientW = function (i) {\r\n      if (arguments.length === 0) {\r\n        return GradientW\r\n      } else {\r\n        GradientW = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.attract = function (i) {\r\n      if (arguments.length === 0) {\r\n        return attractionFactor\r\n      } else {\r\n        attractionFactor = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.iteration = function (i) {\r\n      if (arguments.length === 0) {\r\n        return iteration\r\n      } else {\r\n        iteration = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.autoAdapt = function (i) {\r\n      if (arguments.length === 0) {\r\n        return auto_adaption\r\n      } else {\r\n        auto_adaption = i\r\n      }\r\n      return forcebundle\r\n    }\r\n    /*** ************************ ***/\r\n    return forcebundle\r\n  }\r\n\r\n  static KernelEdgeBundling3D_ADEB() {\r\n    var data_nodes = {}, // {'nodeid':{'x':,'y':},..}\r\n      data_edges = [], // [{'source':'nodeid1', 'target':'nodeid2'},..]\r\n      SplattedAccMap = [],\r\n      DirectionAccMap = [],\r\n      subdivision_points_for_edge = [],\r\n      dircetionC = 0.9,\r\n      splitDistance = 0.01, // 增大或减小, 都会变松. 增大会稍微平滑一点.\r\n      removeDistance = 0.006, // 增大或减小, 都会变松. 增大会平滑些.\r\n      // AccResolution = 100, // 增大, 股数变多. 减小, 股数变小.\r\n      // KernelSize = 7, // 增大, 变松. 减小, 变紧. 默认15, 设为20会平滑一些\r\n      Kernel = getKernel3D(KernelSize),\r\n      // GradientW = 10, // 增大, 变松. 减小, 变紧.\r\n      attractionFactor = 2.0, // 增大, 变紧. 减小, 变松\r\n      iteration = iteration3D,//10,//20\r\n      minn = 100000000000000000,\r\n      maxn = -10000,\r\n      xMin = 100000,\r\n      xMax = -100000,\r\n      yMin = 1000000,\r\n      yMax = -1000000,\r\n\r\n      zMin = 1000000,\r\n      zMax = -1000000,\r\n\r\n      auto_adaption = false\r\n\r\n    /*** Helper Methods ***/\r\n    function filter_self_loops(edgelist) {\r\n      var filtered_edge_list = []\r\n      for (var e = 0; e < edgelist.length; e++) {\r\n        if (\r\n          data_nodes[edgelist[e].source].x !=\r\n          data_nodes[edgelist[e].target].x ||\r\n          data_nodes[edgelist[e].source].y != data_nodes[edgelist[e].target].y\r\n        ) {\r\n          //or smaller than eps\r\n          filtered_edge_list.push(edgelist[e])\r\n        }\r\n      }\r\n\r\n      return filtered_edge_list\r\n    }\r\n\r\n\r\n    function euclidean_distance3D(p, q) {\r\n      return Math.sqrt(Math.pow(p.x - q.x, 2) + Math.pow(p.y - q.y, 2) + Math.pow(p.z - q.z, 2))\r\n    }\r\n\r\n    function toInt32(x) {\r\n      /*** C# convert.ToInt32 ***/\r\n      function help(x) {\r\n        let i = Math.floor(x)\r\n        let j = i + 1\r\n        let z = Math.round(x)\r\n        if (x == (i + j) / 2) {\r\n          if (i % 2 == 0) return i\r\n          return j\r\n        }\r\n        return z\r\n      }\r\n      if (x >= 0) return help(x)\r\n      else {\r\n        x = -x\r\n        return -help(x)\r\n      }\r\n    }\r\n    /*** ********************** ***/\r\n\r\n\r\n    /*** Initialization Methods ***/\r\n    function getKernel3D(KernSize) {\r\n      let Kernel = []\r\n      for (let i = 0; i < KernSize * KernSize * KernSize; i++) Kernel.push(0)\r\n      for (let i = 0; i < KernSize * KernSize * KernSize; i += KernSize * KernSize) {\r\n        for (let j = 0; j < KernSize * KernSize; j += KernSize) {\r\n          for (let k = 0; k < KernSize; k++) {\r\n            let temp1 = k - (KernSize - 1) / 2\r\n            let temp2 = j / KernSize - (KernSize - 1) / 2\r\n            let temp3 = i / KernSize / KernSize - (KernSize - 1) / 2\r\n            let centerDist = Math.sqrt(temp1 * temp1 + temp2 * temp2 + temp3 * temp3)\r\n            Kernel[i + j + k] = Math.max(\r\n              0,\r\n              1 - Math.abs((2 / (KernSize - 1)) * centerDist)\r\n            )\r\n          }\r\n        }\r\n      }\r\n      return Kernel\r\n    }\r\n\r\n\r\n    function NodeNormalize3D() {\r\n      for (var key in data_nodes) {\r\n        var item = data_nodes[key]\r\n        xMin = Math.min(xMin, item.x)\r\n        xMax = Math.max(xMax, item.x)\r\n\r\n        yMin = Math.min(yMin, item.y)\r\n        yMax = Math.max(yMax, item.y)\r\n\r\n        zMin = Math.min(zMin, item.z)\r\n        zMax = Math.max(zMax, item.z)\r\n      }\r\n    }\r\n\r\n\r\n    function antiNormalize3D() {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let point of line) {\r\n          point.x = point.x * (xMax - xMin) + xMin\r\n          point.y = point.y * (yMax - yMin) + yMin\r\n          point.z = point.z * (zMax - zMin) + zMin\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    function initialize_edge_subdivisions3D() {\r\n      for (var i = 0; i < data_edges.length; i++) {\r\n        subdivision_points_for_edge[i] = []\r\n        subdivision_points_for_edge[i].push({\r\n          id: data_edges[i].source,\r\n          x: (data_nodes[data_edges[i].source].x - xMin) / (xMax - xMin),\r\n          y: (data_nodes[data_edges[i].source].y - yMin) / (yMax - yMin),\r\n          z: (data_nodes[data_edges[i].source].z - zMin) / (zMax - zMin),\r\n          value: data_edges[i].value,\r\n        })\r\n\r\n        subdivision_points_for_edge[i].push({\r\n          id: data_edges[i].target,\r\n          x: (data_nodes[data_edges[i].target].x - xMin) / (xMax - xMin),\r\n          y: (data_nodes[data_edges[i].target].y - yMin) / (yMax - yMin),\r\n          z: (data_nodes[data_edges[i].target].z - zMin) / (zMax - zMin),\r\n          value: data_edges[i].value,\r\n        })\r\n      }\r\n    }\r\n\r\n    /*** Main Bundling Loop Methods ***/\r\n    var forcebundle = function () {\r\n      //NodeNormalize()\r\n      NodeNormalize3D()\r\n\r\n      //initialize_edge_subdivisions()\r\n      initialize_edge_subdivisions3D()\r\n\r\n      //initializeBytes()\r\n      Resample3D_const()\r\n\r\n      for (let i = 0; i < iteration; i++) {\r\n        if (auto_adaption == true && i == ~~(iteration * 0.6)) {\r\n          AccResolution = AccResolution * 2\r\n          KernelSize = KernelSize - 2\r\n          //Kernel = getKernel(KernelSize)\r\n          Kernel = getKernel3D(KernelSize)\r\n        }\r\n        bundle3D()\r\n        console.log(\"第\", i, \"次迭代\")\r\n\r\n      }\r\n      antiNormalize3D()\r\n      return subdivision_points_for_edge\r\n    }\r\n    /*** ************************ ***/\r\n\r\n    /*** Force Calculation Methods ***/\r\n\r\n    function bundle3D() {\r\n\r\n      //Resample3D(splitDistance, removeDistance)\r\n\r\n      // Splatting\r\n      //ComputeSplatting()\r\n      ComputeSplatting3D()\r\n\r\n      // // Apply Gradient\r\n      ApplyGradient3D(GradientW, attractionFactor, SplattedAccMap)\r\n\r\n      // Smooth trajectories\r\n      for (let i = 0; i < smoothNum; i++) {\r\n        SmoothTrajectories3D()\r\n      }\r\n    }\r\n\r\n\r\n    function Resample3D() {\r\n      let tempVertex = subdivision_points_for_edge\r\n      for (let i = 0; i < tempVertex.length; i++) {\r\n        let tmpVertexList = []\r\n        tmpVertexList.push(tempVertex[i][0])\r\n        for (let j = 0; j < tempVertex[i].length - 1; j++) {\r\n          let currentVert = tempVertex[i][j]\r\n          let nextVert = tempVertex[i][j + 1]\r\n          let dist = euclidean_distance3D(currentVert, nextVert)\r\n          if (dist > splitDistance) {\r\n            let x = currentVert['x'] + nextVert['x']\r\n            let y = currentVert['y'] + nextVert['y']\r\n            let z = currentVert['z'] + nextVert['z']\r\n            let value = currentVert.value\r\n            tmpVertexList.push({ x: x / 2, y: y / 2, z: z / 2, value: value })\r\n          }\r\n          if (!(dist < removeDistance) || j == tempVertex[i].length - 2) {\r\n            tmpVertexList.push(nextVert)\r\n          }\r\n        }\r\n        tempVertex[i] = tmpVertexList\r\n      }\r\n      subdivision_points_for_edge = tempVertex\r\n    }\r\n\r\n    function Resample3D_const() {//对每一条边进行采样\r\n      let tempVertex = subdivision_points_for_edge\r\n      let statistics = {}\r\n      for (let i = 0; i < tempVertex.length; i++) {\r\n        let tmpVertexList = []\r\n        tmpVertexList.push(tempVertex[i][0])//每条边的起始点\r\n        let startX = tempVertex[i][0][\"x\"]\r\n        let startY = tempVertex[i][0][\"y\"]\r\n        let startZ = tempVertex[i][0][\"z\"]\r\n\r\n        let endX = tempVertex[i][tempVertex[i].length - 1][\"x\"]\r\n        let endY = tempVertex[i][tempVertex[i].length - 1][\"y\"]\r\n        let endZ = tempVertex[i][tempVertex[i].length - 1][\"z\"]\r\n\r\n        let value = tempVertex[i][0][\"value\"]\r\n\r\n        let dist = Math.sqrt((endX - startX) * (endX - startX) + (endY - startY) * (endY - startY) + (endZ - startZ) * (endZ - startZ))\r\n        let minDist = 0.01\r\n        let num = 0\r\n        for (let k = 1; true; k++) {\r\n          let nx = (endX - startX) * (k * minDist / dist) + startX\r\n          let ny = (endY - startY) * (k * minDist / dist) + startY\r\n          let nz = (endZ - startZ) * (k * minDist / dist) + startZ\r\n\r\n          num++\r\n\r\n          if ((nx - startX) * (nx - endX) >= 0) {\r\n            tmpVertexList.push(tempVertex[i][tempVertex[i].length - 1])\r\n            statistics[num] = statistics[num] === undefined ? 1 : statistics[num] + 1\r\n            break\r\n          } else {\r\n            tmpVertexList.push({ x: nx, y: ny, z: nz, value: value })\r\n          }\r\n        }\r\n        tempVertex[i] = tmpVertexList\r\n      }\r\n      subdivision_points_for_edge = tempVertex\r\n    }\r\n\r\n\r\n    let sum = 0\r\n    function ComputeSplatting3D() {//计算AccMap 和 DAccMap\r\n      let AccMap = []\r\n      let DAccMap = []\r\n      for (let i = 0; i < AccResolution * AccResolution * AccResolution; i++) AccMap.push(0)\r\n      for (let i = 0; i < AccResolution * AccResolution * AccResolution; i++) DAccMap.push({ x: 0, y: 0, z: 0 })\r\n      for (let line of subdivision_points_for_edge) {\r\n        let lineIndex = 0\r\n        for (let point of line) {\r\n          //计算该点的方向\r\n          let curPoint = line[lineIndex]\r\n          let nexPoint = lineIndex === line.length - 1 ? line[lineIndex - 1] : line[lineIndex + 1]\r\n          let vx = 0, vy = 0, vz = 0;\r\n          if (lineIndex === line.length - 1) {\r\n            vx = curPoint[\"x\"] - nexPoint[\"x\"]\r\n            vy = curPoint[\"y\"] - nexPoint[\"y\"]\r\n            vz = curPoint[\"z\"] - nexPoint[\"z\"]\r\n          } else {\r\n            vx = nexPoint[\"x\"] - curPoint[\"x\"]\r\n            vy = nexPoint[\"y\"] - curPoint[\"y\"]\r\n            vz = nexPoint[\"z\"] - curPoint[\"z\"]\r\n          }\r\n          let dist = Math.sqrt(vx * vx + vy * vy + vz * vz)\r\n          dist = dist === 0 ? 0.000000001 : dist\r\n          vx = vx / dist\r\n          vy = vy / dist\r\n          vz = vz / dist\r\n          lineIndex++\r\n          for (let i = 0; i < KernelSize * KernelSize * KernelSize; i += KernelSize * KernelSize) {\r\n            for (let j = 0; j < KernelSize * KernelSize; j += KernelSize) {\r\n              for (let k = 0; k < KernelSize; k++) {\r\n                //~~运算符：将字符串转成数字\r\n                let x =\r\n                  toInt32(point['x'] * AccResolution) * AccResolution * AccResolution +\r\n                  (~~(i / KernelSize / KernelSize) - ~~(KernelSize / 2)) * AccResolution * AccResolution\r\n                let y =\r\n                  toInt32(point['y'] * AccResolution) * AccResolution + (~~(j / KernelSize) - ~~(KernelSize / 2)) * AccResolution\r\n                //j - ~~(KernelSize / 2)\r\n                let z =\r\n                  toInt32(point['z'] * AccResolution) + (~~(k) - ~~(KernelSize / 2))\r\n                if (x > 0 && x < AccMap.length && y > 0 && y < AccResolution * AccResolution && z > 0 && z < AccResolution) {\r\n\r\n                  AccMap[x + y + z] += Kernel[i + j + k] * point.value\r\n\r\n                  let DX = DAccMap[x + y + z].x + vx * Kernel[i + j + k],\r\n                    DY = DAccMap[x + y + z].y + vy * Kernel[i + j + k],\r\n                    DZ = DAccMap[x + y + z].z + vz * Kernel[i + j + k]\r\n\r\n                  DAccMap[x + y + z] = { x: DX, y: DY, z: DZ }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      SplattedAccMap = AccMap\r\n      DirectionAccMap = DAccMap\r\n    }\r\n\r\n    //GradientW:15  attractionFactor:1.0    \r\n    function ApplyGradient3D(GradientW, attractionFactor, SplattedAccMap) {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let j = 1; j < line.length - 1; j++) {\r\n          let pointIndex =\r\n            toInt32(line[j]['x'] * AccResolution) * AccResolution * AccResolution +\r\n            toInt32(line[j]['y'] * AccResolution) * AccResolution +\r\n            toInt32(line[j]['z'] * AccResolution)\r\n\r\n\r\n          let localGradient = GetLocalGradient3D(\r\n            GradientW,\r\n            SplattedAccMap,\r\n            line[j],\r\n            pointIndex,\r\n            DirectionAccMap,\r\n            line,\r\n            j\r\n          )\r\n\r\n          if (localGradient[0] != 0 || localGradient[1] != 0 || localGradient[2] != 0)\r\n            localGradient = gradientNormalize3D(localGradient)\r\n          line[j]['x'] =\r\n            line[j]['x'] + (attractionFactor * localGradient[0]) / AccResolution\r\n          line[j]['y'] =\r\n            line[j]['y'] + (attractionFactor * localGradient[1]) / AccResolution\r\n          line[j]['z'] =\r\n            line[j]['z'] + (attractionFactor * localGradient[2]) / AccResolution\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    function GetLocalGradient3D(gradientW, AccMap, point, pointIndex, DirectionAccMap, line, curIndex) {\r\n      let localGradient1 = 0\r\n      let localGradient2 = 0\r\n      let localGradient3 = 0\r\n\r\n      let nexPoint = line[curIndex + 1]\r\n      let cx = nexPoint[\"x\"] - point[\"x\"]\r\n      let cy = nexPoint[\"y\"] - point[\"y\"]\r\n      let cz = nexPoint[\"z\"] - point[\"z\"]\r\n      let curdist = Math.sqrt(cx * cx + cy * cy + cz * cz)\r\n      cx = cx / curdist\r\n      cy = cy / curdist\r\n      cz = cz / curdist\r\n\r\n      for (let i = 0; i < gradientW; i++) {\r\n        for (let j = 0; j < gradientW; j++) {\r\n          for (let k = 0; k < gradientW; k++) {\r\n            let offsetIndex =\r\n              (i - ~~(GradientW / 2)) * AccResolution * AccResolution + (j - ~~(GradientW / 2)) * AccResolution + (k - ~~(GradientW / 2))\r\n\r\n            if (\r\n              ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) > 0 &&\r\n              ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) < AccResolution &&\r\n              ~~(((pointIndex + offsetIndex) - ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) * AccResolution * AccResolution) / AccResolution) > 0 &&\r\n              ~~(((pointIndex + offsetIndex) - ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) * AccResolution * AccResolution) / AccResolution) < AccResolution &&\r\n              (pointIndex + offsetIndex) % AccResolution > 0 &&\r\n              (pointIndex + offsetIndex) % AccResolution < AccResolution\r\n            ) {\r\n              let localDensity = AccMap[pointIndex + offsetIndex]\r\n              let dX = i - ~~(GradientW / 2)\r\n              let dY = j - ~~(GradientW / 2)\r\n              let dZ = k - ~~(GradientW / 2)\r\n\r\n              let localDirectionDensity = DirectionAccMap[pointIndex + offsetIndex]\r\n              let { x, y, z } = localDirectionDensity\r\n              let localDist = Math.sqrt(x * x + y * y + z * z)\r\n              let cosValue = (x * cx + y * cy + z * cz) / localDist\r\n\r\n              if (localDist !== 0 && cosValue > dircetionC) {\r\n                localGradient1 += localDensity * dX\r\n                localGradient2 += localDensity * dY\r\n                localGradient3 += localDensity * dZ\r\n              }\r\n\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return [localGradient1, localGradient2, localGradient3]\r\n    }\r\n\r\n    function gradientNormalize3D(localGradient) {\r\n      let x = localGradient[0]\r\n      let y = localGradient[1]\r\n      let z = localGradient[2]\r\n      let l = Math.sqrt(x * x + y * y + z * z)\r\n      localGradient[0] = x / l\r\n      localGradient[1] = y / l\r\n      localGradient[2] = z / l\r\n      return localGradient\r\n    }\r\n    function SmoothTrajectories3D() {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let i = 1; i < line.length - 1; i++) {\r\n          line[i]['x'] =\r\n            (line[i - 1]['x'] + line[i]['x'] + line[i + 1]['x']) / 3\r\n          line[i]['y'] =\r\n            (line[i - 1]['y'] + line[i]['y'] + line[i + 1]['y']) / 3\r\n          line[i]['z'] =\r\n            (line[i - 1]['z'] + line[i]['z'] + line[i + 1]['z']) / 3\r\n        }\r\n      }\r\n    }\r\n    /*** ********************** ***/\r\n\r\n    /*** Getters/Setters Methods ***/\r\n    forcebundle.nodes = function (nl) {\r\n      if (arguments.length === 0) {\r\n        return data_nodes\r\n      } else {\r\n        data_nodes = nl\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.edges = function (ll) {\r\n      if (arguments.length === 0) {\r\n        return data_edges\r\n      } else {\r\n        data_edges = filter_self_loops(ll) //remove edges to from to the same point\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.splitDis = function (i) {\r\n      if (arguments.length === 0) {\r\n        return splitDistance\r\n      } else {\r\n        splitDistance = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.removeDis = function (i) {\r\n      if (arguments.length === 0) {\r\n        return removeDistance\r\n      } else {\r\n        removeDistance = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.resolution = function (i) {\r\n      if (arguments.length === 0) {\r\n        return AccResolution\r\n      } else {\r\n        AccResolution = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.kernelSize = function (i) {\r\n      if (arguments.length === 0) {\r\n        return KernelSize\r\n      } else {\r\n        KernelSize = i\r\n        Kernel = getKernel3D(KernelSize)\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.gradientW = function (i) {\r\n      if (arguments.length === 0) {\r\n        return GradientW\r\n      } else {\r\n        GradientW = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.attract = function (i) {\r\n      if (arguments.length === 0) {\r\n        return attractionFactor\r\n      } else {\r\n        attractionFactor = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.iteration = function (i) {\r\n      if (arguments.length === 0) {\r\n        return iteration\r\n      } else {\r\n        iteration = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.autoAdapt = function (i) {\r\n      if (arguments.length === 0) {\r\n        return auto_adaption\r\n      } else {\r\n        auto_adaption = i\r\n      }\r\n      return forcebundle\r\n    }\r\n    /*** ************************ ***/\r\n    return forcebundle\r\n  }\r\n\r\n  static KernelEdgeBundling3D_ADEB2() {\r\n    var data_nodes = {}, // {'nodeid':{'x':,'y':},..}\r\n      data_edges = [], // [{'source':'nodeid1', 'target':'nodeid2'},..]\r\n      SplattedAccMap = [],\r\n      DirectionAccMap = [],\r\n      subdivision_points_for_edge = [],\r\n      dircetionC = 0.95,\r\n      splitDistance = 0.01, // 增大或减小, 都会变松. 增大会稍微平滑一点.\r\n      removeDistance = 0.006, // 增大或减小, 都会变松. 增大会平滑些.\r\n      // AccResolution = 100, // 增大, 股数变多. 减小, 股数变小.\r\n      // KernelSize = 5, // 增大, 变松. 减小, 变紧. 默认15, 设为20会平滑一些\r\n      Kernel = [],//getKernel3D(KernelSize),\r\n      // GradientW = 10, // 增大, 变松. 减小, 变紧.\r\n      attractionFactor = 2.0, // 增大, 变紧. 减小, 变松\r\n      iteration = iteration3D,//10,//20\r\n      minn = 100000000000000000,\r\n      maxn = -10000,\r\n      xMin = 100000,\r\n      xMax = -100000,\r\n      yMin = 1000000,\r\n      yMax = -1000000,\r\n\r\n      zMin = 1000000,\r\n      zMax = -1000000,\r\n\r\n      auto_adaption = false\r\n\r\n    /*** Helper Methods ***/\r\n    function filter_self_loops(edgelist) {\r\n      var filtered_edge_list = []\r\n      for (var e = 0; e < edgelist.length; e++) {\r\n        if (\r\n          data_nodes[edgelist[e].source].x !=\r\n          data_nodes[edgelist[e].target].x ||\r\n          data_nodes[edgelist[e].source].y != data_nodes[edgelist[e].target].y\r\n        ) {\r\n          //or smaller than eps\r\n          filtered_edge_list.push(edgelist[e])\r\n        }\r\n      }\r\n\r\n      return filtered_edge_list\r\n    }\r\n\r\n\r\n    function euclidean_distance3D(p, q) {\r\n      return Math.sqrt(Math.pow(p.x - q.x, 2) + Math.pow(p.y - q.y, 2) + Math.pow(p.z - q.z, 2))\r\n    }\r\n\r\n    function toInt32(x) {\r\n      /*** C# convert.ToInt32 ***/\r\n      function help(x) {\r\n        let i = Math.floor(x)\r\n        let j = i + 1\r\n        let z = Math.round(x)\r\n        if (x == (i + j) / 2) {\r\n          if (i % 2 == 0) return i\r\n          return j\r\n        }\r\n        return z\r\n      }\r\n      if (x >= 0) return help(x)\r\n      else {\r\n        x = -x\r\n        return -help(x)\r\n      }\r\n    }\r\n    /*** ********************** ***/\r\n\r\n    function GaussianDistribute(pointDistK, centerDist) {//a是西格玛的平方 ,a越小峰值越高,0.2-5,pointDist越大，a越大\r\n      let minA = 10\r\n      let maxA = 100\r\n      let x = centerDist\r\n      let k = (0.5 - pointDistK) * 2\r\n\r\n      let a = k * (maxA - minA) + minA\r\n      return 1 / (Math.sqrt(2 * Math.PI * a)) * Math.exp(-(x) * (x) / (2 * a))\r\n    }\r\n\r\n    /*** Initialization Methods ***/\r\n    function getKernel3D(KernSize) {\r\n      let Kernel = []\r\n      for (let i = 0; i < KernSize * KernSize * KernSize; i++) Kernel.push(0)\r\n      for (let i = 0; i < KernSize * KernSize * KernSize; i += KernSize * KernSize) {\r\n        for (let j = 0; j < KernSize * KernSize; j += KernSize) {\r\n          for (let k = 0; k < KernSize; k++) {\r\n            let temp1 = k - (KernSize - 1) / 2\r\n            let temp2 = j / KernSize - (KernSize - 1) / 2\r\n            let temp3 = i / KernSize / KernSize - (KernSize - 1) / 2\r\n            let centerDist = Math.sqrt(temp1 * temp1 + temp2 * temp2 + temp3 * temp3)\r\n            Kernel[i + j + k] = Math.max(\r\n              0,\r\n              1 - Math.abs((2 / (KernSize - 1)) * centerDist)\r\n            )\r\n          }\r\n        }\r\n      }\r\n      return Kernel\r\n    }\r\n\r\n    function getGaussianKernel3D(KernSize, pointDistK) {\r\n      let Kernel = []\r\n      for (let i = 0; i < KernSize * KernSize * KernSize; i++) Kernel.push(0)\r\n      for (let i = 0; i < KernSize * KernSize * KernSize; i += KernSize * KernSize) {\r\n        for (let j = 0; j < KernSize * KernSize; j += KernSize) {\r\n          for (let k = 0; k < KernSize; k++) {\r\n            let temp1 = k - (KernSize - 1) / 2\r\n            let temp2 = j / KernSize - (KernSize - 1) / 2\r\n            let temp3 = i / KernSize / KernSize - (KernSize - 1) / 2\r\n            let centerDist = Math.sqrt(temp1 * temp1 + temp2 * temp2 + temp3 * temp3)\r\n            Kernel[i + j + k] = GaussianDistribute(pointDistK, centerDist);\r\n          }\r\n        }\r\n      }\r\n      return Kernel\r\n    }\r\n\r\n    function NodeNormalize3D() {\r\n      for (var key in data_nodes) {\r\n        var item = data_nodes[key]\r\n        xMin = Math.min(xMin, item.x)\r\n        xMax = Math.max(xMax, item.x)\r\n\r\n        yMin = Math.min(yMin, item.y)\r\n        yMax = Math.max(yMax, item.y)\r\n\r\n        zMin = Math.min(zMin, item.z)\r\n        zMax = Math.max(zMax, item.z)\r\n      }\r\n    }\r\n\r\n\r\n    function antiNormalize3D() {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let point of line) {\r\n          point.x = point.x * (xMax - xMin) + xMin\r\n          point.y = point.y * (yMax - yMin) + yMin\r\n          point.z = point.z * (zMax - zMin) + zMin\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    function initialize_edge_subdivisions3D() {\r\n      for (var i = 0; i < data_edges.length; i++) {\r\n        subdivision_points_for_edge[i] = []\r\n        subdivision_points_for_edge[i].push({\r\n          id: data_edges[i].source,\r\n          x: (data_nodes[data_edges[i].source].x - xMin) / (xMax - xMin),\r\n          y: (data_nodes[data_edges[i].source].y - yMin) / (yMax - yMin),\r\n          z: (data_nodes[data_edges[i].source].z - zMin) / (zMax - zMin),\r\n          value: data_edges[i].value,\r\n        })\r\n\r\n        subdivision_points_for_edge[i].push({\r\n          id: data_edges[i].target,\r\n          x: (data_nodes[data_edges[i].target].x - xMin) / (xMax - xMin),\r\n          y: (data_nodes[data_edges[i].target].y - yMin) / (yMax - yMin),\r\n          z: (data_nodes[data_edges[i].target].z - zMin) / (zMax - zMin),\r\n          value: data_edges[i].value,\r\n        })\r\n      }\r\n    }\r\n\r\n    /*** Main Bundling Loop Methods ***/\r\n    var forcebundle = function () {\r\n      //NodeNormalize()\r\n      NodeNormalize3D()\r\n\r\n      //initialize_edge_subdivisions()\r\n      initialize_edge_subdivisions3D()\r\n\r\n      //initializeBytes()\r\n      Resample3D_const()\r\n\r\n\r\n      for (let i = 0; i < iteration; i++) {\r\n        if (auto_adaption == true && i == ~~(iteration * 0.6)) {\r\n          AccResolution = AccResolution * 2\r\n          KernelSize = KernelSize - 2\r\n          //Kernel = getKernel(KernelSize)\r\n          //Kernel = getKernel3D(KernelSize)\r\n        }\r\n        bundle3D()\r\n        console.log(\"第\", i, \"次迭代\")\r\n\r\n      }\r\n      antiNormalize3D()\r\n      return subdivision_points_for_edge\r\n    }\r\n    /*** ************************ ***/\r\n\r\n    /*** Force Calculation Methods ***/\r\n\r\n    function bundle3D() {\r\n\r\n      console.time(1)\r\n      ComputeSplatting3D()//每一次执行都至少需要2s，对他加速\r\n      console.timeEnd(1)\r\n\r\n      // // Apply Gradient\r\n      ApplyGradient3D(GradientW, attractionFactor, SplattedAccMap)//每一次执行0.4秒，考虑加速\r\n\r\n      // Smooth trajectories\r\n      for (let i = 0; i < smoothNum; i++) {\r\n        SmoothTrajectories3D()\r\n      }\r\n    }\r\n\r\n\r\n    function Resample3D() {\r\n      let tempVertex = subdivision_points_for_edge\r\n      for (let i = 0; i < tempVertex.length; i++) {\r\n        let tmpVertexList = []\r\n        tmpVertexList.push(tempVertex[i][0])\r\n        for (let j = 0; j < tempVertex[i].length - 1; j++) {\r\n          let currentVert = tempVertex[i][j]\r\n          let nextVert = tempVertex[i][j + 1]\r\n          let dist = euclidean_distance3D(currentVert, nextVert)\r\n          if (dist > splitDistance) {\r\n            let x = currentVert['x'] + nextVert['x']\r\n            let y = currentVert['y'] + nextVert['y']\r\n            let z = currentVert['z'] + nextVert['z']\r\n            let value = currentVert.value\r\n            tmpVertexList.push({ x: x / 2, y: y / 2, z: z / 2, value: value })\r\n          }\r\n          if (!(dist < removeDistance) || j == tempVertex[i].length - 2) {\r\n            tmpVertexList.push(nextVert)\r\n          }\r\n        }\r\n        tempVertex[i] = tmpVertexList\r\n      }\r\n      subdivision_points_for_edge = tempVertex\r\n    }\r\n\r\n    function Resample3D_const() {//对每一条边进行采样\r\n      let tempVertex = subdivision_points_for_edge\r\n      let statistics = {}\r\n      for (let i = 0; i < tempVertex.length; i++) {\r\n        let tmpVertexList = []\r\n        tmpVertexList.push(tempVertex[i][0])//每条边的起始点\r\n        let startX = tempVertex[i][0][\"x\"]\r\n        let startY = tempVertex[i][0][\"y\"]\r\n        let startZ = tempVertex[i][0][\"z\"]\r\n\r\n        let endX = tempVertex[i][tempVertex[i].length - 1][\"x\"]\r\n        let endY = tempVertex[i][tempVertex[i].length - 1][\"y\"]\r\n        let endZ = tempVertex[i][tempVertex[i].length - 1][\"z\"]\r\n\r\n        let value = tempVertex[i][0][\"value\"]\r\n\r\n        let dist = Math.sqrt((endX - startX) * (endX - startX) + (endY - startY) * (endY - startY) + (endZ - startZ) * (endZ - startZ))\r\n        let minDist = 0.02\r\n        let num = 0\r\n        for (let k = 1; true; k++) {\r\n          let nx = (endX - startX) * (k * minDist / dist) + startX\r\n          let ny = (endY - startY) * (k * minDist / dist) + startY\r\n          let nz = (endZ - startZ) * (k * minDist / dist) + startZ\r\n\r\n          num++\r\n\r\n          if ((nx - startX) * (nx - endX) >= 0) {\r\n            tmpVertexList.push(tempVertex[i][tempVertex[i].length - 1])\r\n            statistics[num] = statistics[num] === undefined ? 1 : statistics[num] + 1\r\n            break\r\n          } else {\r\n            tmpVertexList.push({ x: nx, y: ny, z: nz, value: value })\r\n          }\r\n        }\r\n        tempVertex[i] = tmpVertexList\r\n      }\r\n      subdivision_points_for_edge = tempVertex\r\n    }\r\n\r\n\r\n    let sum = 0\r\n    function ComputeSplatting3D() {//计算AccMap 和 DAccMap\r\n      let AccMap = []\r\n      let DAccMap = []\r\n      console.time(2)\r\n      for (let i = 0; i < AccResolution * AccResolution * AccResolution; i++) AccMap.push(0)\r\n      for (let i = 0; i < AccResolution * AccResolution * AccResolution; i++) DAccMap.push({ x: 0, y: 0, z: 0 })\r\n      console.timeEnd(2)\r\n      console.time(3)\r\n      for (let line of subdivision_points_for_edge) {\r\n        let lineIndex = 0\r\n        let lineLength = euclidean_distance3D(line[0], line[line.length - 1])\r\n        for (let point of line) {\r\n          //计算该点的方向\r\n          let curPoint = line[lineIndex]\r\n          let nexPoint = lineIndex === line.length - 1 ? line[lineIndex - 1] : line[lineIndex + 1]\r\n          let vx = 0, vy = 0, vz = 0;\r\n          if (lineIndex === line.length - 1) {\r\n            vx = curPoint[\"x\"] - nexPoint[\"x\"]\r\n            vy = curPoint[\"y\"] - nexPoint[\"y\"]\r\n            vz = curPoint[\"z\"] - nexPoint[\"z\"]\r\n          } else {\r\n            vx = nexPoint[\"x\"] - curPoint[\"x\"]\r\n            vy = nexPoint[\"y\"] - curPoint[\"y\"]\r\n            vz = nexPoint[\"z\"] - curPoint[\"z\"]\r\n          }\r\n          let dist = Math.sqrt(vx * vx + vy * vy + vz * vz)\r\n          dist = dist === 0 ? 0.000000001 : dist\r\n          vx = vx / dist\r\n          vy = vy / dist\r\n          vz = vz / dist\r\n          lineIndex++\r\n          //计算该点的kernel\r\n          let l1 = euclidean_distance3D(line[0], curPoint)\r\n          let l2 = euclidean_distance3D(line[line.length - 1], curPoint)\r\n          let smallLength = l1 > l2 ? l2 : l1\r\n          let distK = smallLength / lineLength\r\n          Kernel = getGaussianKernel3D(KernelSize, distK)\r\n          if (sum < 0) {\r\n            console.log(distK, Kernel)\r\n            sum++\r\n          }\r\n          for (let i = 0; i < KernelSize * KernelSize * KernelSize; i += KernelSize * KernelSize) {\r\n            for (let j = 0; j < KernelSize * KernelSize; j += KernelSize) {\r\n              for (let k = 0; k < KernelSize; k++) {\r\n                //~~运算符：将字符串转成数字\r\n                let x =\r\n                  toInt32(point['x'] * AccResolution) * AccResolution * AccResolution +\r\n                  (~~(i / KernelSize / KernelSize) - ~~(KernelSize / 2)) * AccResolution * AccResolution\r\n                let y =\r\n                  toInt32(point['y'] * AccResolution) * AccResolution + (~~(j / KernelSize) - ~~(KernelSize / 2)) * AccResolution\r\n                //j - ~~(KernelSize / 2)\r\n                let z =\r\n                  toInt32(point['z'] * AccResolution) + (~~(k) - ~~(KernelSize / 2))\r\n                if (x > 0 && x < AccMap.length && y > 0 && y < AccResolution * AccResolution && z > 0 && z < AccResolution) {\r\n\r\n                  AccMap[x + y + z] += Kernel[i + j + k] * point.value * (distK * 2)\r\n\r\n                  let DX = DAccMap[x + y + z].x + vx * Kernel[i + j + k],\r\n                    DY = DAccMap[x + y + z].y + vy * Kernel[i + j + k],\r\n                    DZ = DAccMap[x + y + z].z + vz * Kernel[i + j + k]\r\n\r\n                  DAccMap[x + y + z] = { x: DX, y: DY, z: DZ }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n      console.timeEnd(3)\r\n      SplattedAccMap = AccMap\r\n      DirectionAccMap = DAccMap\r\n    }\r\n\r\n    //GradientW:15  attractionFactor:1.0    \r\n    function ApplyGradient3D(GradientW, attractionFactor, SplattedAccMap) {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let j = 1; j < line.length - 1; j++) {\r\n          let pointIndex =\r\n            toInt32(line[j]['x'] * AccResolution) * AccResolution * AccResolution +\r\n            toInt32(line[j]['y'] * AccResolution) * AccResolution +\r\n            toInt32(line[j]['z'] * AccResolution)\r\n\r\n\r\n          let localGradient = GetLocalGradient3D(\r\n            GradientW,\r\n            SplattedAccMap,\r\n            line[j],\r\n            pointIndex,\r\n            DirectionAccMap,\r\n            line,\r\n            j\r\n          )\r\n\r\n          if (localGradient[0] != 0 || localGradient[1] != 0 || localGradient[2] != 0)\r\n            localGradient = gradientNormalize3D(localGradient)\r\n          line[j]['x'] =\r\n            line[j]['x'] + (attractionFactor * localGradient[0]) / AccResolution\r\n          line[j]['y'] =\r\n            line[j]['y'] + (attractionFactor * localGradient[1]) / AccResolution\r\n          line[j]['z'] =\r\n            line[j]['z'] + (attractionFactor * localGradient[2]) / AccResolution\r\n        }\r\n      }\r\n    }\r\n\r\n\r\n    function GetLocalGradient3D(gradientW, AccMap, point, pointIndex, DirectionAccMap, line, curIndex) {\r\n      let localGradient1 = 0\r\n      let localGradient2 = 0\r\n      let localGradient3 = 0\r\n\r\n      let nexPoint = line[curIndex + 1]\r\n      let cx = nexPoint[\"x\"] - point[\"x\"]\r\n      let cy = nexPoint[\"y\"] - point[\"y\"]\r\n      let cz = nexPoint[\"z\"] - point[\"z\"]\r\n      let curdist = Math.sqrt(cx * cx + cy * cy + cz * cz)\r\n      cx = cx / curdist\r\n      cy = cy / curdist\r\n      cz = cz / curdist\r\n\r\n      for (let i = 0; i < gradientW; i++) {\r\n        for (let j = 0; j < gradientW; j++) {\r\n          for (let k = 0; k < gradientW; k++) {\r\n            let offsetIndex =\r\n              (i - ~~(GradientW / 2)) * AccResolution * AccResolution + (j - ~~(GradientW / 2)) * AccResolution + (k - ~~(GradientW / 2))\r\n\r\n            if (\r\n              ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) > 0 &&\r\n              ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) < AccResolution &&\r\n              ~~(((pointIndex + offsetIndex) - ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) * AccResolution * AccResolution) / AccResolution) > 0 &&\r\n              ~~(((pointIndex + offsetIndex) - ~~((pointIndex + offsetIndex) / AccResolution / AccResolution) * AccResolution * AccResolution) / AccResolution) < AccResolution &&\r\n              (pointIndex + offsetIndex) % AccResolution > 0 &&\r\n              (pointIndex + offsetIndex) % AccResolution < AccResolution\r\n            ) {\r\n              let localDensity = AccMap[pointIndex + offsetIndex]\r\n              let dX = i - ~~(GradientW / 2)\r\n              let dY = j - ~~(GradientW / 2)\r\n              let dZ = k - ~~(GradientW / 2)\r\n\r\n              let localDirectionDensity = DirectionAccMap[pointIndex + offsetIndex]\r\n              let { x, y, z } = localDirectionDensity\r\n              let localDist = Math.sqrt(x * x + y * y + z * z)\r\n              let cosValue = (x * cx + y * cy + z * cz) / localDist\r\n\r\n              if (localDist !== 0 && cosValue > dircetionC) {\r\n                localGradient1 += localDensity * dX\r\n                localGradient2 += localDensity * dY\r\n                localGradient3 += localDensity * dZ\r\n              }\r\n\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return [localGradient1, localGradient2, localGradient3]\r\n    }\r\n\r\n    function gradientNormalize3D(localGradient) {\r\n      let x = localGradient[0]\r\n      let y = localGradient[1]\r\n      let z = localGradient[2]\r\n      let l = Math.sqrt(x * x + y * y + z * z)\r\n      localGradient[0] = x / l\r\n      localGradient[1] = y / l\r\n      localGradient[2] = z / l\r\n      return localGradient\r\n    }\r\n    function SmoothTrajectories3D() {\r\n      for (let line of subdivision_points_for_edge) {\r\n        for (let i = 1; i < line.length - 1; i++) {\r\n          line[i]['x'] =\r\n            (line[i - 1]['x'] + line[i]['x'] + line[i + 1]['x']) / 3\r\n          line[i]['y'] =\r\n            (line[i - 1]['y'] + line[i]['y'] + line[i + 1]['y']) / 3\r\n          line[i]['z'] =\r\n            (line[i - 1]['z'] + line[i]['z'] + line[i + 1]['z']) / 3\r\n        }\r\n      }\r\n    }\r\n    /*** ********************** ***/\r\n\r\n    /*** Getters/Setters Methods ***/\r\n    forcebundle.nodes = function (nl) {\r\n      if (arguments.length === 0) {\r\n        return data_nodes\r\n      } else {\r\n        data_nodes = nl\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.edges = function (ll) {\r\n      if (arguments.length === 0) {\r\n        return data_edges\r\n      } else {\r\n        data_edges = filter_self_loops(ll) //remove edges to from to the same point\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.splitDis = function (i) {\r\n      if (arguments.length === 0) {\r\n        return splitDistance\r\n      } else {\r\n        splitDistance = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.removeDis = function (i) {\r\n      if (arguments.length === 0) {\r\n        return removeDistance\r\n      } else {\r\n        removeDistance = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.resolution = function (i) {\r\n      if (arguments.length === 0) {\r\n        return AccResolution\r\n      } else {\r\n        AccResolution = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.kernelSize = function (i) {\r\n      if (arguments.length === 0) {\r\n        return KernelSize\r\n      } else {\r\n        KernelSize = i\r\n        Kernel = getKernel3D(KernelSize)\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.gradientW = function (i) {\r\n      if (arguments.length === 0) {\r\n        return GradientW\r\n      } else {\r\n        GradientW = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.attract = function (i) {\r\n      if (arguments.length === 0) {\r\n        return attractionFactor\r\n      } else {\r\n        attractionFactor = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.iteration = function (i) {\r\n      if (arguments.length === 0) {\r\n        return iteration\r\n      } else {\r\n        iteration = i\r\n      }\r\n      return forcebundle\r\n    }\r\n\r\n    forcebundle.autoAdapt = function (i) {\r\n      if (arguments.length === 0) {\r\n        return auto_adaption\r\n      } else {\r\n        auto_adaption = i\r\n      }\r\n      return forcebundle\r\n    }\r\n    /*** ************************ ***/\r\n    return forcebundle\r\n  }\r\n\r\n}","import { path } from \"@loaders.gl/loader-utils\";\r\nimport china from \"../data/china.json\"\r\nimport coordinatesData from \"../data/coordinates.json\"\r\nimport rawData from \"../data/rawData.json\"\r\nimport ABlevel from \"./ABlevel\";\r\nimport KernelEdgeBundling from \"./EdgeBundling\";\r\nimport * as d3 from \"d3\"\r\n\r\nfor (let attr in coordinatesData) {\r\n    coordinatesData[attr].x = coordinatesData[attr].x * 3\r\n    coordinatesData[attr].y = coordinatesData[attr].y * 3\r\n}\r\n\r\n\r\nexport default class ComputeData {\r\n    static typeHeight = { \"A_N\": 70, \"A_C\": 0, \"M\": 120, \"B_C\": 170, \"B_N\": 240 }\r\n    constructor() {\r\n        this.ColorEB = [d3.rgb(0, 255, 128), d3.rgb(0, 0, 255)]\r\n        this.ColorDC = [d3.rgb(255, 255, 0), d3.rgb(0, 0, 0)]\r\n\r\n        this.typeHeight = ComputeData.typeHeight\r\n        this.isSkipZero = true\r\n        this.isSkipBusinessCore = true\r\n        this.isCheckPathNegative = true\r\n        this.isMerge_FT_Edeges = true\r\n\r\n        this.china = china;\r\n        this.coordinatesData = coordinatesData\r\n\r\n        this.typeLine = {\r\n            \"A_C\": [],//A中 核心层与核心层相连的线, 格式为：{from_city, from_coordinates, from_dev, from_level, from_port, to_city, to_coordinates, to_dev, to_level, to_port, traffic, bdUtilization}\r\n            \"A_N\": [],//A中 一般层与一般层相连的线\r\n            \"A_CN\": [],//A中 核心层与一般层相连的线\r\n            \"B_C\": [],//B中 核心层与核心层相连的线\r\n            \"B_N\": [],//B中 一般层与一般层相连的线\r\n            \"B_CN\": [],//B中 核心层与核心层相连的线\r\n            \"AB\": [],//A平面与B平面相连的线\r\n            \"M\": []//与AB平面都相连，但不属于AB平面的点所连接的线\r\n        }\r\n        this.allNodes = {} //格式为:{\"上海1129\":{city, dev, coordinates, traffic, bdU, type},  ,,,,,}\r\n        let data = this.processRawData(rawData)\r\n        this.generateTypeData(data) //生成了allNodes和typeLine数据\r\n\r\n    }\r\n\r\n    getWidth(k,value,maxValue){\r\n        return (k/30*value/maxValue)*3+0.1 >3 ? 3 : (k*value/maxValue)*3+0.1\r\n    }\r\n\r\n    getResults() {\r\n        let EBResults = this.computeEBResults()\r\n        let DCResults = this.computeDCResults()\r\n\r\n        for (let attr in EBResults) {\r\n            let maxValue = (attr.split(\"_b\").length > 1) ? this.maxBdUtilization : this.maxTraffic\r\n            let k = (attr.split(\"_b\").length > 1) ? 500 : 300\r\n            let valueType = (attr.split(\"_b\").length > 1) ? \"bandwidth utilization\" : \"traffic\"\r\n            for (let i = 0; i < EBResults[attr].length; i++) {\r\n                let path = EBResults[attr][i]\r\n                let value = path[0].value\r\n                let color = this.setColor(value, maxValue, k, this.ColorEB[0], this.ColorEB[1] )\r\n                let width = this.getWidth(k,value,maxValue)//(k*value/maxValue)*3+0.5 >3 ? 4 : (k*value/maxValue)*3+0.5\r\n                let info = path[0].id + \"->\" + path[path.length - 1].id + \" \" + valueType + \":\" + value\r\n                let np = []\r\n                for (let j = 0; j < path.length; j++) {\r\n                    let line = path[j]\r\n                    let x = line.x, y = line.y, z = line.z\r\n                    if (this.isCheckPathNegative) {\r\n                        x = x > 0 ? x : 0\r\n                        y = y > 0 ? y : 0\r\n                        z = z > 0 ? z : 0\r\n                    }\r\n                    np[j] = [x, y, z]\r\n                }\r\n                EBResults[attr][i] = { path: np, value, color, info, width }\r\n            }\r\n        }\r\n\r\n        for (let attr in DCResults) {\r\n            let maxValue = (attr.split(\"_b\").length > 1) ? this.maxBdUtilization : this.maxTraffic\r\n            let k = (attr.split(\"_b\").length > 1) ? 500 : 300\r\n            let valueType = (attr.split(\"_b\").length > 1) ? \"bandwidth utilization\" : \"traffic\"\r\n            for (let i = 0; i < DCResults[attr].length; i++) {\r\n                let path = DCResults[attr][i]\r\n                let value = path[0].value\r\n                let np = []\r\n                for (let j = 0; j < path.length; j++) {\r\n                    let line = path[j]\r\n                    np[j] = [line.x, line.y, line.z]\r\n                }\r\n                let color = this.setColor(value, maxValue, k, this.ColorDC[0], this.ColorDC[1])\r\n                let width = this.getWidth(k,value,maxValue)//(k*value/maxValue)*3+0.5 >3 ? 4 : (k*value/maxValue)*3+0.5\r\n                let info = path[0].id + \"->\" + path[path.length - 1].id + \" \" + valueType + \":\" + value\r\n                DCResults[attr][i] = { path: np, value, color, info, width }\r\n            }\r\n        }\r\n        let chinaA = [this.get_China_Data(this.typeHeight[\"A_N\"]), this.get_China_Data(this.typeHeight[\"A_C\"])]\r\n        let chinaB = [this.get_China_Data(this.typeHeight[\"B_N\"]), this.get_China_Data(this.typeHeight[\"B_C\"])]\r\n        let allNodes = this.allNodes\r\n        return { \"DC\": DCResults, \"EB\": EBResults, \"China\": { A: chinaA, B: chinaB }, allNodes }\r\n    }\r\n\r\n    processRawData(data) {\r\n        data.forEach(line => {//加上带宽利用率\r\n            line.bdUtilization = line.traffic / line.bandwidth\r\n        })\r\n\r\n        data = this.merge_Same_Edges(data) //合并 a->b 与 a->b 这样的边\r\n\r\n        if (this.isMerge_FT_Edeges === true) data = this.merge_FT_Edges(data) //合并a->b 与 b->a 这样的边\r\n\r\n        data.forEach(line=>{//求平均的贷款利用率\r\n            line.bdUtilization = line.bdUtilization / line.frequency\r\n        })\r\n\r\n        this.converSourceTarget(data)\r\n\r\n        let maxTraffic = 0, maxBdUtilization = 0;\r\n        //给边加上坐标, 并且重新计算带宽利用率, 并且加上限制,计算最大值\r\n        data.forEach(line => {\r\n            //计算两个点的坐标\r\n            let { from_city, to_city } = line\r\n            let from_coordinates = coordinatesData[from_city]\r\n            let to_coordinates = coordinatesData[to_city]\r\n            if (from_coordinates === undefined) console.log(\"未找到该点坐标：\", from_city)\r\n            if (to_coordinates === undefined) console.log(\"未找到该点坐标：\", to_city)\r\n            line.from_coordinates = from_coordinates\r\n            line.to_coordinates = to_coordinates\r\n            //计算带宽利用率\r\n            line.bdUtilization = line.bdUtilization / line.frequency\r\n            line.frequency = 1\r\n            //给 最大的流量 和 最大的带宽利用率 添加限制条件\r\n            if (this.trafficLimit !== undefined) {\r\n                if (line.traffic > this.trafficLimit) line.traffic = this.trafficLimit\r\n            }\r\n            if (this.bandwidthLimit !== undefined) {\r\n                if (line.bdUtilization > this.bandwidthLimit) line.bdUtilization = this.bandwidthLimit\r\n            }\r\n            //计算最大流量 和 最大 带宽利用率\r\n            if (maxTraffic < line.traffic) maxTraffic = line.traffic\r\n            if (maxBdUtilization < line.bdUtilization) maxBdUtilization = line.bdUtilization\r\n        })\r\n\r\n        this.maxTraffic = maxTraffic\r\n        this.maxBdUtilization = maxBdUtilization\r\n        return data\r\n    }\r\n\r\n    get_China_Data(height) {\r\n        let features = this.china.features\r\n        let withHeightChinaPath = []\r\n        features.forEach(fea => {\r\n            let coordinates = fea.geometry.coordinates\r\n            coordinates.forEach(geo => {\r\n                geo.forEach(path => {\r\n                    let newPath = []\r\n                    path.forEach(obj => {\r\n                        if (height !== undefined) newPath.push([...obj, height])//3D的地图path\r\n                        else newPath.push([...obj])//2D的地图的path\r\n                    })\r\n                    withHeightChinaPath.push({ path: newPath })\r\n                })\r\n            })\r\n\r\n        })\r\n        return withHeightChinaPath\r\n    }\r\n\r\n    generateTypeData(data) {//生成 typeline 和 typenodes\r\n        let allNodes = {}\r\n        let sumObj = {}\r\n\r\n        data.forEach(line => {\r\n            let { from_city, from_coordinates, from_dev, from_level, from_port, to_city, to_coordinates, to_dev, to_level, to_port, traffic, bdUtilization } = line\r\n            //计算typeLine\r\n            let flStr = from_level === \"网络核心\" ? \"C\" : \"N\";\r\n            let tlStr = to_level === \"网络核心\" ? \"C\" : \"N\";\r\n            let fromPlane = ABlevel.getLevel(from_dev, from_city)\r\n            let toPlane = ABlevel.getLevel(to_dev, to_city)\r\n            let planeStr = (fromPlane === toPlane ? fromPlane : ((fromPlane === \"M\" || toPlane === \"M\") ? \"M\" : \"AB\"))\r\n            let levelStr = flStr === tlStr ? flStr : \"CN\"\r\n            let typeStr = planeStr === \"M\" ? \"M\" : (planeStr === \"AB\" ? \"AB\" : (planeStr + \"_\" + levelStr))\r\n            this.typeLine[typeStr].push({ from_city, from_coordinates, from_dev, from_level, from_port, to_city, to_coordinates, to_dev, to_level, to_port, traffic, bdUtilization })\r\n            //计算所有的节点\r\n            let f_cityDev = from_city + \",\" + from_dev\r\n            let t_cityDev = to_city + \",\" + to_dev\r\n            let f_nodeType = fromPlane === \"M\" ? \"M\" : (fromPlane + \"_\" + flStr)\r\n            let t_nodeType = toPlane === \"M\" ? \"M\" : (toPlane + \"_\" + tlStr)\r\n            if (allNodes[f_cityDev] === undefined) {\r\n                sumObj[f_cityDev] = 1\r\n                let { x, y } = from_coordinates\r\n                let z = this.typeHeight[f_nodeType]\r\n                allNodes[f_cityDev] = { city: from_city, dev: from_dev, coordinates: { x, y, z }, traffic, bdUtilization, type: f_nodeType }\r\n            } else {\r\n                allNodes[f_cityDev].traffic = allNodes[f_cityDev].traffic + traffic\r\n                allNodes[f_cityDev].bdUtilization = allNodes[f_cityDev].bdUtilization + bdUtilization\r\n                sumObj[f_cityDev] = sumObj[f_cityDev] + 1\r\n            }\r\n            if (allNodes[t_cityDev] === undefined) {\r\n                sumObj[t_cityDev] = 1\r\n                let { x, y } = to_coordinates\r\n                let z = this.typeHeight[t_nodeType]\r\n                allNodes[t_cityDev] = { city: to_city, dev: to_dev, coordinates: { x, y, z }, traffic, bdUtilization, type: t_nodeType }\r\n            } else {\r\n                allNodes[t_cityDev].traffic = allNodes[t_cityDev].traffic + traffic\r\n                allNodes[t_cityDev].bdUtilization = allNodes[t_cityDev].bdUtilization + bdUtilization\r\n                sumObj[t_cityDev] = sumObj[t_cityDev] + 1\r\n            }\r\n        })\r\n        //计算出每一个节点的带宽利用率\r\n        for (let attr in sumObj) {\r\n            allNodes[attr].bdUtilization = allNodes[attr].bdUtilization / sumObj[attr]\r\n        }\r\n\r\n        this.allNodes = allNodes\r\n    }\r\n\r\n    computeEBResults() {\r\n        let eb_2D = [\"A_C\", \"A_N\", \"B_C\", \"B_N\"]\r\n        let eb_3D = [\"A_CN\", \"B_CN\"]\r\n        let results = {}\r\n        let FINAL = {}\r\n        //先对2D进行边绑定\r\n        eb_2D.forEach(attr => {\r\n            let data = this.typeLine[attr]\r\n            let nodes = {}\r\n            let links_traffic = []\r\n            let links_bd = []\r\n            data.forEach(line => {\r\n                let { from_city, from_dev, from_coordinates, to_city, to_coordinates, to_dev, traffic, bdUtilization } = line\r\n                let fx = from_coordinates.x, fy = from_coordinates.y\r\n                let tx = to_coordinates.x, ty = to_coordinates.y\r\n                let source = from_city + \",\" + from_dev\r\n                let target = to_city + \",\" + to_dev\r\n                nodes[source] = { x: fx, y: fy }\r\n                nodes[target] = { x: tx, y: ty }\r\n                links_traffic.push({ source, target, value: traffic })\r\n                links_bd.push({ source, target, value: bdUtilization })\r\n            })\r\n            let rType1 = attr + \"_traffic\"\r\n            let rType2 = attr + \"_bd\"\r\n            let r1 = KernelEdgeBundling.KernelEdgeBundling2D().nodes(nodes).edges(links_traffic)();\r\n            let r2 = KernelEdgeBundling.KernelEdgeBundling2D().nodes(nodes).edges(links_bd)();\r\n            this.convert2D(r1, attr)\r\n            this.convert2D(r2, attr)\r\n            results[rType1] = r1\r\n            results[rType2] = r2\r\n\r\n        })\r\n\r\n        //再对3D进行边绑定\r\n        eb_3D.forEach(attr => {\r\n            let data = this.typeLine[attr]\r\n            let nodes = {}\r\n            let links_traffic = []\r\n            let links_bd = []\r\n            data.forEach(line => {\r\n                let { from_city, from_dev, from_coordinates, to_city, to_coordinates, to_dev, traffic, bdUtilization } = line\r\n                let fx = from_coordinates.x, fy = from_coordinates.y\r\n                let tx = to_coordinates.x, ty = to_coordinates.y\r\n                let source = from_city + \",\" + from_dev\r\n                let target = to_city + \",\" + to_dev\r\n                let ftype = this.allNodes[source].type\r\n                let ttype = this.allNodes[target].type\r\n                let fz = this.typeHeight[ftype]\r\n                let tz = this.typeHeight[ttype]\r\n\r\n                nodes[source] = { x: fx, y: fy, z: fz }\r\n                nodes[target] = { x: tx, y: ty, z: tz }\r\n                links_traffic.push({ source, target, value: traffic })\r\n                links_bd.push({ source, target, value: bdUtilization })\r\n            })\r\n            let rType1 = attr + \"_traffic\"\r\n            let rType2 = attr + \"_bd\"\r\n            // let r1 = KernelEdgeBundling.KernelEdgeBundling3D_addSpring().nodes(nodes).edges(links_traffic)();\r\n            // let r2 = KernelEdgeBundling.KernelEdgeBundling3D_addSpring().nodes(nodes).edges(links_bd)();\r\n\r\n            // let r1 = KernelEdgeBundling.KernelEdgeBundling3D_addLength().nodes(nodes).edges(links_traffic)();\r\n            // let r2 = KernelEdgeBundling.KernelEdgeBundling3D_addLength().nodes(nodes).edges(links_bd)();\r\n\r\n            // let r1 = KernelEdgeBundling.KernelEdgeBundling3D().nodes(nodes).edges(links_traffic)();\r\n            // let r2 = KernelEdgeBundling.KernelEdgeBundling3D().nodes(nodes).edges(links_bd)();\r\n            // console.log(\"****************************KernelEdgeBundling3D*****************************\")\r\n\r\n            // let r1 = KernelEdgeBundling.KernelEdgeBundling3D_ADEB().nodes(nodes).edges(links_traffic)();\r\n            // let r2 = KernelEdgeBundling.KernelEdgeBundling3D_ADEB().nodes(nodes).edges(links_bd)();\r\n            // console.log(\"****************************KernelEdgeBundling3D_ADEB*****************************\")\r\n\r\n            let r1 = KernelEdgeBundling.KernelEdgeBundling3D_ADEB2().nodes(nodes).edges(links_traffic)();\r\n            let r2 = KernelEdgeBundling.KernelEdgeBundling3D_ADEB2().nodes(nodes).edges(links_bd)();\r\n            console.log(\"****************************KernelEdgeBundling3D_ADEB2*****************************\")\r\n\r\n\r\n            results[rType1] = r1\r\n            results[rType2] = r2\r\n        })\r\n\r\n        let ABresult = { \"AB_bd\": [], \"AB_traffic\": [] }\r\n        this.typeLine[\"AB\"].forEach(line => {\r\n            let { from_city, from_dev, from_coordinates, to_city, to_coordinates, to_dev, traffic, bdUtilization } = line\r\n            let source = from_city + \",\" + from_dev\r\n            let fx = from_coordinates.x, fy = from_coordinates.y, fz = this.typeHeight[this.allNodes[source].type]\r\n            let target = to_city + \",\" + to_dev\r\n            let tx = to_coordinates.x, ty = to_coordinates.y, tz = this.typeHeight[this.allNodes[target].type]\r\n            if (from_city === to_city) ty = ty + 0.0001\r\n            ABresult[\"AB_bd\"].push([{ id: source, x: fx, y: fy, z: fz, value: bdUtilization }, { id: target, x: tx, y: ty, z: tz, value: bdUtilization }])\r\n            ABresult[\"AB_traffic\"].push([{ id: source, x: fx, y: fy, z: fz, value: traffic }, { id: target, x: tx, y: ty, z: tz, value: traffic }])\r\n        })\r\n\r\n        let Mresult = { \"M_bd\": [], \"M_traffic\": [] }\r\n        this.typeLine[\"M\"].forEach(line => {\r\n            let { from_city, from_dev, from_coordinates, to_city, to_coordinates, to_dev, traffic, bdUtilization } = line\r\n            let source = from_city + \",\" + from_dev\r\n            let fx = from_coordinates.x, fy = from_coordinates.y, fz = this.typeHeight[this.allNodes[source].type]\r\n            let target = to_city + \",\" + to_dev\r\n            let tx = to_coordinates.x, ty = to_coordinates.y, tz = this.typeHeight[this.allNodes[target].type]\r\n            Mresult[\"M_bd\"].push([{ id: source, x: fx, y: fy, z: fz, value: bdUtilization }, { id: target, x: tx, y: ty, z: tz, value: bdUtilization }])\r\n            Mresult[\"M_traffic\"].push([{ id: source, x: fx, y: fy, z: fz, value: traffic }, { id: target, x: tx, y: ty, z: tz, value: traffic }])\r\n        })\r\n\r\n\r\n        FINAL[\"A_bd\"] = [...results[\"A_C_bd\"], ...results[\"A_N_bd\"], ...results[\"A_CN_bd\"]]\r\n        FINAL[\"A_traffic\"] = [...results[\"A_C_traffic\"], ...results[\"A_N_traffic\"], ...results[\"A_CN_traffic\"]]\r\n\r\n        FINAL[\"B_bd\"] = [...results[\"B_C_bd\"], ...results[\"B_N_bd\"], ...results[\"B_CN_bd\"]]\r\n        FINAL[\"B_traffic\"] = [...results[\"B_C_traffic\"], ...results[\"B_N_traffic\"], ...results[\"B_CN_traffic\"]]\r\n\r\n        FINAL[\"AB_bd\"] = [...Mresult[\"M_bd\"], ...ABresult[\"AB_bd\"], ...FINAL[\"A_bd\"], ...FINAL[\"B_bd\"]]\r\n        FINAL[\"AB_traffic\"] = [...Mresult[\"M_traffic\"], ...ABresult[\"AB_traffic\"], ...FINAL[\"A_traffic\"], ...FINAL[\"B_traffic\"]]\r\n\r\n        return FINAL\r\n    }\r\n\r\n    computeDCResults() {\r\n        let planeA = [\"A_C\", \"A_N\", \"A_CN\"]\r\n        let planeB = [\"B_C\", \"B_N\", \"B_CN\"]\r\n        let results = { \"A_traffic\": [], \"A_bd\": [], \"B_traffic\": [], \"B_bd\": [], \"AB_traffic\": [], \"AB_bd\": [] }\r\n        for (let attr in this.typeLine) {\r\n            this.typeLine[attr].forEach(line => {\r\n                let { from_city, from_dev, from_coordinates, to_city, to_coordinates, to_dev, traffic, bdUtilization } = line\r\n                let source = from_city + \",\" + from_dev\r\n                let fx = from_coordinates.x, fy = from_coordinates.y, fz = this.typeHeight[this.allNodes[source].type]\r\n                let target = to_city + \",\" + to_dev\r\n                let tx = to_coordinates.x, ty = to_coordinates.y, tz = this.typeHeight[this.allNodes[target].type]\r\n\r\n                if (planeA.indexOf(attr) > -1) {\r\n                    results[\"A_traffic\"].push([{ id: source, x: fx, y: fy, z: fz, value: traffic }, { id: target, x: tx, y: ty, z: tz, value: traffic }])\r\n                    results[\"A_bd\"].push([{ id: source, x: fx, y: fy, z: fz, value: bdUtilization }, { id: target, x: tx, y: ty, z: tz, value: bdUtilization }])\r\n                } else if (planeB.indexOf(attr) > -1) {\r\n                    results[\"B_traffic\"].push([{ id: source, x: fx, y: fy, z: fz, value: traffic }, { id: target, x: tx, y: ty, z: tz, value: traffic }])\r\n                    results[\"B_bd\"].push([{ id: source, x: fx, y: fy, z: fz, value: bdUtilization }, { id: target, x: tx, y: ty, z: tz, value: bdUtilization }])\r\n                } else {\r\n                    if (from_city === to_city) ty = ty + 0.0001\r\n                    results[\"AB_traffic\"].push([{ id: source, x: fx, y: fy, z: fz, value: traffic }, { id: target, x: tx, y: ty, z: tz, value: traffic }])\r\n                    results[\"AB_bd\"].push([{ id: source, x: fx, y: fy, z: fz, value: bdUtilization }, { id: target, x: tx, y: ty, z: tz, value: bdUtilization }])\r\n                }\r\n            })\r\n        }\r\n        results[\"AB_traffic\"] = [...results[\"AB_traffic\"], ...results[\"A_traffic\"], ...results[\"B_traffic\"]]\r\n        results[\"AB_bd\"] = [...results[\"AB_bd\"], ...results[\"A_bd\"], ...results[\"B_bd\"]]\r\n        return results\r\n    }\r\n\r\n    convert2D(data, type) {\r\n        let z = this.typeHeight[type]\r\n        data.forEach(path => {\r\n            path.forEach(line => {\r\n                line.z = z\r\n            })\r\n        })\r\n    }\r\n\r\n    setColor(value, maxValue, k, from, to) {\r\n        let t = value / maxValue * k\r\n        if (t > 1) t = 1\r\n        from = from === undefined ? d3.rgb(0, 255, 128) : from\r\n        to = to === undefined ? d3.rgb(0, 0, 255) : to\r\n        let f2t = d3.interpolate(from, to)\r\n        let rgbArr = f2t(t).replace(\"rgb(\", \"\").replace(\")\", \"\").split(\",\")\r\n\r\n        return [parseInt(rgbArr[0]), parseInt(rgbArr[1]), parseInt(rgbArr[2])]\r\n    }\r\n\r\n    saveTypeNodes(nodeObj, sumObj, city, dev, traffic, bandwidth) {\r\n        let nodeStr = city + dev\r\n        if (nodeObj[nodeStr] === undefined) {\r\n            nodeObj[nodeStr] = { name: city, dev, traffic, bandwidth }\r\n            sumObj[nodeStr] = 1\r\n        } else {\r\n            nodeObj[nodeStr].traffic = nodeObj[nodeStr].traffic + traffic\r\n            nodeObj[nodeStr].bandwidth = nodeObj[nodeStr].bandwidth + bandwidth\r\n            sumObj[nodeStr] = sumObj[nodeStr] + 1\r\n        }\r\n    }\r\n\r\n    setMaxTrafficLimit(limit) {\r\n        this.trafficLimit = limit\r\n        return this\r\n    }\r\n    setMaxBandwidthLimit(limit) {\r\n        this.bandwidthLimit = limit\r\n        return this\r\n    }\r\n    setLevelScale(levelHeight) {//格式为{\"一般\":0}\r\n        this.levelHeight = levelHeight\r\n        return this\r\n    }\r\n\r\n    isCheckPathNegative(isCheckPathNegative) {\r\n        this.isCheckPathNegative = isCheckPathNegative === undefined ? true : isCheckPathNegative\r\n    }\r\n\r\n    isMerge_FT_Edges(isMerge_FT_Edeges) {\r\n        this.isMerge_FT_Edeges = (isMerge_FT_Edeges !== undefined ? isMerge_FT_Edeges : true)//是否合并 a->b 和 b->a 这样的边, 默认是合并\r\n        return this\r\n    }\r\n    isSkipZero(isSkipZero) {\r\n        this.isSkipZero = isSkipZero === undefined ? true : isSkipZero\r\n    }\r\n    isSkipBusinessCore(isSkipBusinessCore) {\r\n        this.isSkipBusinessCore = isSkipBusinessCore === undefined ? true : isSkipBusinessCore\r\n    }\r\n\r\n    merge_Same_Edges(data) {//由原始数据，合并相同的边，比如 a->b 和 a->b 这样的边\r\n        let indexObj = {}\r\n        let mergesData = []\r\n        for (let i = 0; i < data.length; i++) {\r\n            let { from_city, from_dev, from_level, from_port, to_city, to_dev, to_level, to_port, traffic, bandwidth, bdUtilization } = data[i]\r\n            traffic = +traffic\r\n            bandwidth = +bandwidth\r\n            //跳过什么样的数据\r\n            if (isNaN(traffic) || isNaN(bandwidth)) continue\r\n            if (this.isSkipZero && (traffic === 0 || bandwidth === 0)) continue\r\n            if (this.isSkipBusinessCore && (from_level === \"业务核心\" || to_level === \"业务核心\")) continue\r\n\r\n            let fromObjStr = from_city + from_dev, toObjStr = to_city + to_dev;\r\n            let edgeStr = fromObjStr + toObjStr\r\n            if (indexObj[edgeStr] === undefined) {\r\n                indexObj[edgeStr] = mergesData.length\r\n                mergesData.push({ from_city, from_dev, from_level, from_port, to_city, to_dev, to_level, to_port, traffic, bandwidth, bdUtilization, frequency: 1 })\r\n            } else {\r\n                let index = indexObj[edgeStr]\r\n\r\n                mergesData[index].traffic = mergesData[index].traffic + traffic\r\n                mergesData[index].bdUtilization = mergesData[index].bdUtilization + bdUtilization\r\n                mergesData[index].frequency = mergesData[index].frequency + 1\r\n            }\r\n        }\r\n\r\n        return mergesData\r\n    }\r\n\r\n    merge_FT_Edges(data) {//合并 a->b 和 b->a 这样的边\r\n        let mergeFTData = []\r\n        let indexObj_FT = {}\r\n        for (let i = 0; i < data.length; i++) {\r\n            let { from_city, from_dev, from_level, from_port, to_city, to_dev, to_level, to_port, traffic, bandwidth, frequency, bdUtilization } = data[i]\r\n            let fromStr = from_city + from_dev\r\n            let toStr = to_city + to_dev\r\n            let FT = fromStr+toStr\r\n            let TF = toStr+fromStr\r\n            if (indexObj_FT[FT] === undefined) {\r\n                indexObj_FT[FT] = indexObj_FT[TF] = mergeFTData.length\r\n                mergeFTData.push({ from_city, from_dev, from_level, from_port, to_city, to_dev, to_level, to_port, traffic, bandwidth, frequency, bdUtilization })\r\n            } else {\r\n                let index = indexObj_FT[FT]\r\n                mergeFTData[index].traffic = mergeFTData[index].traffic + traffic\r\n                mergeFTData[index].bdUtilization = mergeFTData[index].bdUtilization + bdUtilization\r\n                mergeFTData[index].frequency = mergeFTData[index].frequency + frequency\r\n            }\r\n        }\r\n        return mergeFTData\r\n    }\r\n\r\n\r\n    getProgressInfo(setMapProgress) {\r\n        this.setMapProgress = setMapProgress;\r\n    }\r\n\r\n    converSourceTarget(data){//以网络核心为起点，以一般节点为终点\r\n        data.forEach(line=>{\r\n            let { from_city, from_dev, from_level, from_port, to_level}  = line\r\n            if(from_level === \"一般节点\" && to_level===\"网络核心\"){\r\n                let temp_city = from_city,\r\n                    temp_dev = from_dev,\r\n                    temp_level = from_level,\r\n                    temp_port = from_port\r\n\r\n                line.from_city = line.to_city\r\n                line.to_city = temp_city\r\n\r\n                line.from_dev = line.to_dev\r\n                line.to_dev = temp_dev\r\n\r\n                line.from_level = line.to_level\r\n                line.to_level = temp_level\r\n                \r\n                line.from_port = line.to_port\r\n                line.to_port = temp_port\r\n            }\r\n        })\r\n    }\r\n}","import React, { Component } from 'react'\r\nimport DeckGL from '@deck.gl/react'\r\nimport { LineLayer, PathLayer, ScatterplotLayer, TextLayer, PolygonLayer } from '@deck.gl/layers'\r\nimport { OrbitView } from \"@deck.gl/core\"\r\nimport PubSub from \"pubsub-js\"\r\nimport ComputeData from \"./ComputeData\"\r\n\r\nexport default class Map extends Component {\r\n\r\n    highlightColor = \"#44ffff\";\r\n    deHighlightColor = \"#ffffff\";\r\n    hasDraw = {\r\n        hasClick: [],\r\n        hasConvert: []\r\n    }\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.allLayers= {}\r\n        this.state = {\r\n            isFinish: false,\r\n            progress: 0,\r\n            layers: [],\r\n            button: {\r\n                dataKind: { traffic: true, bd: false },\r\n                edgeKind: { EB: false, DC: true },\r\n                plane: { A: true, B: true },\r\n                netflow: false\r\n            }\r\n        };\r\n        this.INITIAL_VIEW_STATE = {\r\n            target: [965.7479834999999, 300.012138, 0],\r\n            zoom: 1,\r\n            rotationOrbit: 0,\r\n            rotationX: 40,\r\n            minRotationX: -90,\r\n            maxRotationX: 90,\r\n            minZoom: -10,\r\n            maxZoom: 10\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.token = PubSub.subscribe('data', (_, stateObj) => {\r\n            this.setState(stateObj)\r\n            console.log(\"接收数据后状态为：\", this.state)\r\n            let { results } = this.state\r\n            let allNodes = results.allNodes\r\n            let maxNodeTraffic = 0, maxNodeBd = 0\r\n            for (let attr in allNodes) {\r\n                let node = allNodes[attr]\r\n                let { traffic, bdUtilization } = node\r\n                if (traffic > maxNodeTraffic) maxNodeTraffic = traffic\r\n                if (bdUtilization > maxNodeBd) maxNodeBd = bdUtilization\r\n            }\r\n            this.maxNodeBd = maxNodeBd\r\n            this.maxNodeTraffic = maxNodeTraffic\r\n            let layers = this.initLayers()\r\n            this.setState({ layers })\r\n        });\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        PubSub.unsubscribe(this.token)\r\n    }\r\n    initLayers = () => {//把这个方法拆分，拆分成 更新topo graph ,更新netflow及其自环，更新scatterplot， 更新polygon\r\n        let newResults = []\r\n        let strArr = []\r\n        let { results, button, netflowResults } = this.state\r\n        let { allNodes } = results\r\n        let STR = [[], [], []]\r\n        this.hasDraw = {\r\n            hasClick: [],\r\n            hasConvert: []\r\n        }\r\n\r\n\r\n        for (let kind in button[\"edgeKind\"]) {\r\n            if (button[\"edgeKind\"][kind]) STR[0].push(kind)\r\n        }\r\n        for (let kind in button[\"dataKind\"]) {\r\n            if (button[\"dataKind\"][kind]) STR[1].push(kind)\r\n        }\r\n        for (let kind in button[\"plane\"]) {//值为 A 或 B\r\n            if (button[\"plane\"][kind]) STR[2].push(kind)\r\n        }\r\n\r\n        for (let i = 0; i < STR[0].length; i++) {//edgeKind: EB绑定， DC直连\r\n            let r1 = results[STR[0][i]]\r\n\r\n            for (let j = 0; j < STR[1].length; j++) {//datakind : traffic 还是bd\r\n                let dataStr = STR[1][j]\r\n                let planeStr = STR[2].length === 2 ? \"AB\" : (STR[2].length === 1 ? STR[2][0] : \"\")//平面 A 还是 B, 或者是AB\r\n                if (planeStr === \"\") continue\r\n                let attr = planeStr + \"_\" + dataStr\r\n                newResults.push(r1[attr])\r\n                strArr.push(STR[0][i] + \"_\" + attr)\r\n            }\r\n        }\r\n\r\n        let layers = []\r\n        let scatterSet = new Set()\r\n        let scatterData = { bd: [], traffic: [] }\r\n        this.allLayers[\"pathLayer\"] = layers\r\n\r\n        //计算pathlayer, 以及处理scatterplot\r\n        for (let i = 0; i < newResults.length; i++) {\r\n            let r = newResults[i]\r\n            let id = String(strArr[i])\r\n            let p = this.getPathLayer(r, id)\r\n            layers.push(p)\r\n            r.forEach(path => {\r\n                let starr = path.info.split(\" \")[0].split(\"->\")\r\n                let source = starr[0]\r\n                let target = starr[1]\r\n                if (!scatterSet.has(source)) {\r\n                    scatterSet.add(source)\r\n                    let node = allNodes[source]\r\n                    let { x, y, z } = node.coordinates\r\n                    let { traffic, bdUtilization, type } = node\r\n                    let color = type.indexOf(\"C\") > 0 ? [255, 0, 0] : [0, 0, 255]\r\n                    let r_t = this.getScatterRadius(traffic, \"traffic\")\r\n                    let r_b = this.getScatterRadius(bdUtilization, \"bd\")\r\n                    scatterData.bd.push({ info: source, position: [x, y, z], value: bdUtilization, radius: r_b, fillColor: color })\r\n                    scatterData.traffic.push({ info: source, position: [x, y, z], value: traffic, radius: r_t, fillColor: color })\r\n                }\r\n                if (!scatterSet.has(target)) {\r\n                    scatterSet.add(target)\r\n                    let node = allNodes[target]\r\n                    let { x, y, z } = node.coordinates\r\n                    let { traffic, bdUtilization, type } = node\r\n                    let color = type.indexOf(\"C\") > 0 ? [255, 0, 0] : [0, 0, 255]\r\n                    let r_t = this.getScatterRadius(traffic, \"traffic\")\r\n                    let r_b = this.getScatterRadius(bdUtilization, \"bd\")\r\n                    scatterData.bd.push({ info: target, position: [x, y, z], value: bdUtilization, radius: r_b, fillColor: color })\r\n                    scatterData.traffic.push({ info: target, position: [x, y, z], value: traffic, radius: r_t, fillColor: color })\r\n                }\r\n\r\n            })\r\n\r\n        }\r\n        let datakind = STR[1].length !== 0 ? STR[1][0] : \"\"\r\n        let netflowLayers = []\r\n        this.allLayers[\"netflowLayer\"] = netflowLayers\r\n        if (button[\"netflow\"]) {\r\n            if (button[\"edgeKind\"][\"EB\"] === false && button[\"edgeKind\"][\"DC\"] === false) {\r\n\r\n            } else {\r\n                if (button[\"edgeKind\"][\"EB\"]) {\r\n                    netflowLayers.push(this.getPathLayer(netflowResults.edge[\"EB\"], \"netflow-EB\"))\r\n                }\r\n                if (button[\"edgeKind\"][\"DC\"]) {\r\n                    netflowLayers.push(this.getPathLayer(netflowResults.edge[\"DC\"], \"netflow-DC\"))\r\n                }\r\n                //加入所有的点\r\n                let nodes = netflowResults.nodes\r\n                for (let attr in nodes) {\r\n                    if (!scatterSet.has(attr)) {\r\n                        let position = nodes[attr].coordinates\r\n                        let value = nodes[attr].value\r\n                        let radius = nodes[attr].radius\r\n                        let fillColor = nodes[attr].fillColor\r\n                        scatterData[datakind].push({ info: attr, position, value, radius, fillColor })\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //计算netflow的自环\r\n        let ringLayers = []\r\n        this.allLayers[\"ringLayer\"] = ringLayers\r\n        let ringID = 0\r\n        if (button[\"netflow\"]) {\r\n            netflowResults[\"edge\"][\"Ring\"].forEach(line => {\r\n                let { city, color, coordinates, value } = line\r\n                let radius = netflowResults[\"nodes\"][city][\"radius\"] * 1.5\r\n                let z = coordinates[2]\r\n                let x0 = coordinates[0] - radius\r\n                let y0 = coordinates[1] - radius\r\n\r\n                let x1 = coordinates[0] + radius\r\n                let y1 = coordinates[1] - radius\r\n\r\n                let x2 = coordinates[0] + radius\r\n                let y2 = coordinates[1] + radius\r\n\r\n                let x3 = coordinates[0] - radius\r\n                let y3 = coordinates[1] + radius\r\n\r\n                let polygonData = [{ contour: [[x0, y0, z], [x1, y1, z], [x2, y2, z], [x3, y3, z], [x0, y0, z]] }]\r\n                ringLayers.push(this.getCircleLayer(polygonData, \"ring\" + ringID, [0, 0, 255]))\r\n                ringID++\r\n            })\r\n        }\r\n\r\n\r\n\r\n        let minX = 1000000, maxX = 0\r\n        let minY = 1000000, maxY = 0\r\n        scatterData[datakind].forEach(line => {\r\n            let x = line.position[0]\r\n            let y = line.position[1]\r\n            if (minX > x) minX = x\r\n            if (maxX < x) maxX = x\r\n            if (minY > y) minY = y\r\n            if (maxY < y) maxY = y\r\n        })\r\n\r\n        layers = [...layers, ...netflowLayers, ...ringLayers]\r\n\r\n\r\n        //计算scatterPlot Layer\r\n        let scatterLayer = datakind === \"\" ? null : this.getScatterPlotLayer(scatterData[datakind], \"scatter-plot\")\r\n        this.scatterData = scatterData[datakind]\r\n        let textLayer = this.getTextLayer(scatterData[datakind], \"text\")\r\n\r\n        this.allLayers[\"scatterLayer\"] = [scatterLayer]\r\n        layers.push(scatterLayer)\r\n        this.allLayers[\"textLayer\"] = [textLayer]\r\n        layers.push(textLayer)\r\n\r\n\r\n        //计算平面的数据\r\n        let A0 = ComputeData.typeHeight[\"A_N\"]\r\n        let A1 = ComputeData.typeHeight[\"A_C\"]\r\n        let B0 = ComputeData.typeHeight[\"B_C\"]\r\n        let B1 = ComputeData.typeHeight[\"B_N\"]\r\n        let polygonData0 = [{ contour: [[minX, minY, A0], [minX, maxY, A0], [maxX, maxY, A0], [maxX, minY, A0], [minX, minY, A0]] }]\r\n        let polygonData1 = [{ contour: [[minX, minY, A1], [minX, maxY, A1], [maxX, maxY, A1], [maxX, minY, A1], [minX, minY, A1]] }]\r\n        let polygonData2 = [{ contour: [[minX, minY, B0], [minX, maxY, B0], [maxX, maxY, B0], [maxX, minY, B0], [minX, minY, B0]] }]\r\n        let polygonData3 = [{ contour: [[minX, minY, B1], [minX, maxY, B1], [maxX, maxY, B1], [maxX, minY, B1], [minX, minY, B1]] }]\r\n        let polygonArr = []\r\n        this.allLayers[\"polygonLayer\"] = polygonArr\r\n\r\n        const normalPlaneColor = [0, 0, 255, 10]\r\n        const corePlaneColor = [255, 0, 0, 10]\r\n\r\n        if (STR[2].length === 2 && newResults.length !== 0) {\r\n            polygonArr.push(this.getPolygonLayer(polygonData0, \"p0\", normalPlaneColor))\r\n            polygonArr.push(this.getPolygonLayer(polygonData1, \"p1\", corePlaneColor))\r\n            polygonArr.push(this.getPolygonLayer(polygonData2, \"p2\", corePlaneColor))\r\n            polygonArr.push(this.getPolygonLayer(polygonData3, \"p3\", normalPlaneColor))\r\n        } else if (STR[2].length === 1 && newResults.length !== 0) {\r\n            if (STR[2][0] === \"A\") {\r\n                polygonArr.push(this.getPolygonLayer(polygonData0, \"p0\", normalPlaneColor))\r\n                polygonArr.push(this.getPolygonLayer(polygonData1, \"p1\", corePlaneColor))\r\n            } else {\r\n                if (button[\"netflow\"]) {\r\n                    polygonArr.push(this.getPolygonLayer(polygonData0, \"p0\", normalPlaneColor))\r\n                    polygonArr.push(this.getPolygonLayer(polygonData1, \"p1\", corePlaneColor))\r\n                }\r\n                polygonArr.push(this.getPolygonLayer(polygonData2, \"p2\", corePlaneColor))\r\n                polygonArr.push(this.getPolygonLayer(polygonData3, \"p3\", normalPlaneColor))\r\n            }\r\n        } else {\r\n            if (button[\"netflow\"] && STR[0].length !== 0) {\r\n                polygonArr.push(this.getPolygonLayer(polygonData0, \"p0\", normalPlaneColor))\r\n                polygonArr.push(this.getPolygonLayer(polygonData1, \"p1\", corePlaneColor))\r\n            } else {\r\n                polygonArr = []\r\n            }\r\n\r\n        }\r\n\r\n        layers = [...layers, ...polygonArr]\r\n        return layers\r\n    }\r\n\r\n    updateButtonState = (id) => {\r\n        return () => {\r\n            let button = this.state.button\r\n            if (id === \"traffic\" || id === \"bd\") {\r\n                let other = id === \"traffic\" ? \"bd\" : \"traffic\"\r\n                button.dataKind[other] = !button.dataKind[other]\r\n                button.dataKind[id] = !button.dataKind[id]\r\n                this.setState({ button })\r\n            } else if (id === \"EB\" || id === \"DC\") {\r\n                button.edgeKind[id] = !button.edgeKind[id]\r\n                this.setState({ button })\r\n            } else if (id === \"A\" || id === \"B\") {\r\n                button.plane[id] = !button.plane[id]\r\n                this.setState({ button })\r\n            } else {//netflow\r\n                button.netflow = !button.netflow\r\n                this.setState({ button })\r\n            }\r\n            let layers = this.initLayers()\r\n            this.setState({ layers })\r\n            this.combineLayers()\r\n        }\r\n    }\r\n\r\n    getButtonColor = (id) => {\r\n        let button = this.state.button\r\n        let color\r\n        if (id === \"traffic\" || id === \"bd\") {\r\n            color = button.dataKind[id] ? this.highlightColor : this.deHighlightColor\r\n\r\n        } else if (id === \"EB\" || id === \"DC\") {\r\n            color = button.edgeKind[id] ? this.highlightColor : this.deHighlightColor\r\n        } else if (id === \"A\" || id === \"B\") {\r\n            color = button.plane[id] ? this.highlightColor : this.deHighlightColor\r\n        } else {//netflow\r\n            color = this.state.button.netflow ? this.highlightColor : this.deHighlightColor\r\n        }\r\n        return color\r\n    }\r\n\r\n    getScatterRadius = (value, kind) => {//把这个方法放到computeData里面去\r\n        let maxRadius = 8\r\n        let minRadius = 2\r\n        if (kind === \"traffic\") {\r\n            let t = value / this.maxNodeTraffic * 10\r\n            t = t > 1 ? 1 : t\r\n            let radius = parseInt((maxRadius - minRadius) * t + minRadius)\r\n            return radius\r\n        } else {\r\n            let t = value / this.maxNodeBd * 10\r\n            t = t > 1 ? 1 : t\r\n            let radius = (maxRadius - minRadius) * t + minRadius\r\n            return radius\r\n        }\r\n    }\r\n\r\n\r\n\r\n    render() {\r\n        const { isFinish, layers } = this.state\r\n\r\n        return (\r\n            <div>\r\n                {!isFinish ? <h2>正在加载, 请稍后...</h2> :\r\n                    <div>\r\n                        <div id=\"option\">\r\n                            <button onClick={this.updateButtonState(\"traffic\")} style={{ backgroundColor: this.getButtonColor(\"traffic\") }}>Traffic</button>\r\n                            <button onClick={this.updateButtonState(\"bd\")} style={{ backgroundColor: this.getButtonColor(\"bd\") }}>Bandwidth Utilization</button>\r\n                            <button onClick={this.updateButtonState(\"EB\")} style={{ backgroundColor: this.getButtonColor(\"EB\") }}>Edge Bundling</button>\r\n                            <button onClick={this.updateButtonState(\"DC\")} style={{ backgroundColor: this.getButtonColor(\"DC\") }}>Direct Connect</button>\r\n                            <button onClick={this.updateButtonState(\"A\")} style={{ backgroundColor: this.getButtonColor(\"A\") }}>A Plane</button>\r\n                            <button onClick={this.updateButtonState(\"B\")} style={{ backgroundColor: this.getButtonColor(\"B\") }}>B Plane</button>\r\n                            <button onClick={this.updateButtonState(\"netflow\")} style={{ backgroundColor: this.getButtonColor(\"netflow\") }}>Netflow</button>\r\n                        </div>\r\n                        <div id=\"map\">\r\n                            <DeckGL\r\n                                views={new OrbitView({\r\n                                    orbitAxis: 'Z',\r\n                                })}\r\n                                initialViewState={this.INITIAL_VIEW_STATE}\r\n                                controller={true}\r\n                                layers={[...layers]}//{[this.getPathLayer(this.state.graphData,this.getLineColorCB)]}\r\n                            />\r\n                        </div>\r\n\r\n                    </div>\r\n                }\r\n            </div>\r\n\r\n        )\r\n    }\r\n    getPathLayer = (data, layerID, opacity) => {//PathLayer需要d.path, d.color\r\n\r\n        //过滤2D\r\n        data = this.filter2D(data)\r\n\r\n        return new PathLayer({\r\n            id: layerID,\r\n            data: [...data],\r\n            pickable: true,\r\n            widthScale: 1,\r\n            widthMinPixels: 0.1,\r\n            widthMaxPixels: 3,\r\n            getPath: d => { return d.path },\r\n            getColor: d => d.color,\r\n            getWidth: d => { return d.width },\r\n            opacity: opacity === undefined ? 0.2 : opacity,\r\n            billboard: true,\r\n            autoHighlight: true,\r\n            highlightColor: [255, 0, 0],\r\n            onClick: (d) => { this.showInfo(d) }//this.convertEdge(d)  this.showInfo(d)\r\n        });\r\n    }\r\n\r\n    getScatterPlotLayer = (data, layerID) => {//ScatterPlotLayer需要d.fillColor, d.position, d.radius,\r\n        return new ScatterplotLayer({\r\n            id: layerID,\r\n            data: [...data],\r\n            getFillColor: d => d.fillColor,\r\n            getLineColor: [0, 0, 0],\r\n            getPosition: d => { let a = d.position; return d.position },//[a[0]*6, a[1]*4,a[2]]},//{ return [...d.xyz] },\r\n            getRadius: d => { return d.radius },\r\n            lineWidthMinPixels: 0,\r\n            radiusMaxPixels: 100,\r\n            radiusMinPixels: 1,\r\n            radiusScale: 1,\r\n            stroked: false,\r\n            opacity: 1,\r\n            pickable: true,\r\n            autoHighlight: true,\r\n            highlightColor: [255, 215, 0],\r\n            onHover: (info) => this.highlightPoint_Edge(info),\r\n            onClick: (d,event) => {this.clickScatter(d, event)}\r\n        })\r\n    }\r\n\r\n    getTextLayer = (data, layerID) => {//TextLayer需要d.position, d.name\r\n        return new TextLayer({\r\n            id: layerID,\r\n            data: [...data],\r\n            pickable: false,\r\n            getPosition: d => { let a = d.position; return [a[0], a[1], a[2] + 2] },\r\n            getText: d => { return d.info.split(\",\")[0] },\r\n            characterSet: \"auto\",\r\n            getSize: 10,\r\n            getAngle: 0,\r\n            sizeScale: 1.2,\r\n            sizeMinPixels: 10,\r\n            //sizeMaxPixels:1,\r\n            getTextAnchor: 'middle',\r\n            getAlignmentBaseline: 'center'\r\n        });\r\n    }\r\n\r\n    getPolygonLayer = (data, layerID, color) => {\r\n        return new PolygonLayer({\r\n            id: layerID,\r\n            data: data,\r\n            pickable: false,\r\n            stroked: false,\r\n            filled: true,\r\n            wireframe: true,\r\n            lineWidthMinPixels: 1,\r\n            getPolygon: d => d.contour,\r\n            getFillColor: color,\r\n            getLineColor: [80, 80, 80],\r\n            getLineWidth: 0,\r\n            opacity: 1\r\n        })\r\n    }\r\n\r\n    getCircleLayer = (data, layerID, color) => {\r\n        return new PolygonLayer({\r\n            id: layerID,\r\n            data: data,\r\n            pickable: true,\r\n            stroked: true,\r\n            filled: true,\r\n            wireframe: true,\r\n            lineWidthMinPixels: 1,\r\n            getPolygon: d => d.contour,\r\n            //getElevation: d => d.population / d.area / 10,\r\n            getFillColor: [255, 255, 0],\r\n            getLineColor: [255, 255, 0],\r\n            getLineWidth: 1,\r\n            opacity: 1\r\n        })\r\n    }\r\n\r\n    convertEdge = (event) => {//点击一条线，如果是DC的就显示出EB的，反之也可以, 暂时没有用\r\n        let { layer, object } = event\r\n        let edgeKind = layer.id.split(\"_\")[0]// EB或者DC\r\n        let attr = layer.id.replace(String(edgeKind) + \"_\", \"\")\r\n        if (edgeKind !== \"EB\" && edgeKind !== \"DC\") { alert(\"edgeKind出现格式错误\" + String(layer.id)) }\r\n        let ftid = object.info.split(\" \")[0]\r\n        if (ftid === undefined || ftid.indexOf(\"->\") < 0) { alert(\"info出现格式错误\" + String(object.info)) }\r\n        let dataKind = this.state.button.dataKind.traffic ? \"traffic\" : \"bd\"\r\n        let otherKind = edgeKind === \"EB\" ? \"DC\" : \"EB\"\r\n        let { results } = this.state\r\n        let data = results[otherKind][attr]\r\n        for (let i = 0; i < data.length; i++) {\r\n            let info = data[i].info\r\n            if (info.indexOf(ftid) > -1) {\r\n                let layer = this.getPathLayer([data[i]], ftid, false)\r\n                let layers = this.state.layers\r\n                layers = [layer, ...layers]\r\n                this.setState({ layers })\r\n                break\r\n            }\r\n        }\r\n    }\r\n    showInfo = (event) => {\r\n        let info = event.object.info\r\n        info.replace(\"->\", \"<-->\")\r\n        alert(String(info))\r\n    }\r\n\r\n    filter2D = (data) => {\r\n        let newData = []\r\n        data.forEach(line => {\r\n            let path = line.path\r\n            if (path[0][2] !== path[path.length - 1][2]) {\r\n                newData.push(line)\r\n            }\r\n        })\r\n        return newData\r\n    }\r\n\r\n    preState = false\r\n    highlightPoint_Edge = (info) => {\r\n        let netflow = this.state.button.netflow\r\n        if(netflow)return null\r\n        if (info.picked && !this.preState) {\r\n            this.preState = true\r\n            let scatterInfo = info.object.info\r\n            this.updateHighlightPoint_Edge(scatterInfo)\r\n        }\r\n        if (!info.picked && this.preState) {\r\n            this.preState = false\r\n            this.cancelHighlight()\r\n        }\r\n    }\r\n    updateHighlightPoint_Edge(scatterInfo) {\r\n        const { results } = this.state\r\n        const { DC, EB } = results\r\n        let {layers} = this.state\r\n        let dataKind = this.state.button.dataKind.traffic ? \"traffic\" : \"bd\"\r\n        let plane = !this.state.button.plane.A ? (!this.state.button.plane.B ? \"\" : \"B\") : (!this.state.button.plane.B ? \"A\" : \"AB\")\r\n        let edgeKind = this.state.button.edgeKind.EB ? \"EB\" : \"DC\"\r\n        let myData = edgeKind === \"EB\" ? EB : DC\r\n        if (plane === \"\") { return true }\r\n        let data = myData[plane + \"_\" + dataKind]\r\n        if(data === undefined){console.log(\"data出现问题\",plane + \"_\" + dataKind)}\r\n        let highlightEdges = []\r\n        let highlightScatter = []\r\n        let ScatterObj = {}\r\n        data.forEach(line=>{\r\n            let info = line.info\r\n            if(info.indexOf(scatterInfo)>-1){\r\n                let {info, path, value, width} = line\r\n                highlightEdges.push({color:[255,0,0], info, path, value, width})\r\n                let cityArr = info.split(\" \")[0].split(\"->\")\r\n                let source = cityArr[0], target = cityArr[1]\r\n                ScatterObj[source] = true\r\n                ScatterObj[target] = true\r\n            }\r\n        })\r\n        \r\n        this.scatterData.forEach(line=>{\r\n            if(ScatterObj[line.info]===true){\r\n                let {info, radius, value} = line\r\n                let position = [...line.position]\r\n                let fillColor = [255, 215, 0]\r\n                highlightScatter.push({fillColor, info, position, radius, value})\r\n            }\r\n        })\r\n        \r\n        let pathLayer = this.getPathLayer(highlightEdges, \"highlightLayer\", 0.5)\r\n        this.allLayers[\"highlightPahtLayer\"] = [pathLayer]\r\n\r\n        let scatterLayer = this.getScatterPlotLayer(highlightScatter,\"highlightScatter\")\r\n        this.allLayers[\"highlightScatterLayer\"] = [scatterLayer]\r\n\r\n        this.combineLayers()\r\n    }\r\n    cancelHighlight=()=>{\r\n        this.allLayers[\"highlightPahtLayer\"] = []\r\n        this.allLayers[\"highlightScatterLayer\"] = []\r\n        this.combineLayers()\r\n    }\r\n    combineLayers = ()=>{\r\n        let layers = []\r\n        //先放pathLayer，再放netflowLayer，再放ringLayer\r\n        layers=[...this.allLayers.pathLayer, ...this.allLayers.netflowLayer, ...this.allLayers.ringLayer, ...this.allLayers.scatterLayer]\r\n        //再放highlightLayer\r\n        for(let attr in this.allLayers){\r\n            if(attr.indexOf(\"highlight\")>-1){\r\n                layers = [...layers, ...this.allLayers[attr]]\r\n            }\r\n        }\r\n        //再放rightClickLayer\r\n        for(let attr in this.rightClickLayers){\r\n            if(this.rightClickLayers[attr] !== null){\r\n                layers.push(this.rightClickLayers[attr])\r\n            }\r\n        }\r\n        layers = [...layers, ...this.allLayers[\"textLayer\"], ...this.allLayers[\"polygonLayer\"]]\r\n        this.setState({layers})\r\n    }\r\n\r\n\r\n    rightClickScatter = {}\r\n    rightClickLayers = {}\r\n    clickScatter = (d,event)=>{\r\n        if(event.leftButton){\r\n            alert(d.object.info + \" 流量：\" + String(d.object.value))\r\n        }else{\r\n            let scatterID = d.object.info\r\n            if(this.rightClickScatter[scatterID] === undefined) this.rightClickScatter[scatterID] = false\r\n            this.rightClickScatter[scatterID] = !this.rightClickScatter[scatterID]//如果是false，那么就取消跟这个点相关的线，如果是true，那么就显示跟这个点相关的线\r\n            if(!this.rightClickScatter[scatterID]){\r\n                this.rightClickLayers[scatterID] = null\r\n                this.combineLayers()\r\n                return true\r\n                //**********TODO */\r\n            }\r\n            let edgeKind = this.state.button.edgeKind.EB ? \"EB\" : \"DC\"\r\n            if(this.state.button.edgeKind.EB && this.state.button.edgeKind.DC)return null\r\n            const {DC, EB} = this.state.results;\r\n            let dataKind = this.state.button.dataKind.traffic ? \"traffic\" : \"bd\"\r\n            let plane = !this.state.button.plane.A ? (!this.state.button.plane.B ? \"\" : \"B\") : (!this.state.button.plane.B ? \"A\" : \"AB\")\r\n            if (plane === \"\") { return true }\r\n            let myData = edgeKind === \"EB\" ? DC : EB\r\n            let data = myData[plane + \"_\" + dataKind]\r\n            let edgesData = []\r\n            data.forEach(line=>{\r\n                let {info} = line\r\n                if(info.indexOf(scatterID)>-1)edgesData.push(line)\r\n            })\r\n            let layer = this.getPathLayer(edgesData,\"rightClick\"+String(scatterID))\r\n            this.rightClickLayers[scatterID] = layer\r\n            this.combineLayers()\r\n            \r\n        }\r\n    }\r\n\r\n}","import * as d3 from\"d3\"\r\nimport coordinatesData from \"../data/coordinates.json\"\r\nimport ComputeData from \"./ComputeData\"\r\nimport KernelEdgeBundling from \"./EdgeBundling\";\r\n\r\nfor(let attr in coordinatesData){\r\n    coordinatesData[attr].x= coordinatesData[attr].x *3\r\n    coordinatesData[attr].y= coordinatesData[attr].y *3\r\n}\r\n\r\nexport default class Netflow{\r\n    NETFLOW_DATA = [\r\n        \"0,北京,网络核心,0,上海,网络核心,13811\",\r\n        \"0,北京,网络核心,0,云南,一般节点,3196\",\r\n        \"0,北京,网络核心,0,内蒙古,一般节点,33922\",\r\n        \"0,北京,网络核心,0,吉林,一般节点,228128\",\r\n        \"0,北京,网络核心,0,四川,网络核心,43530\",\r\n        \"0,北京,网络核心,0,天津,网络核心,135093\",\r\n        \"0,北京,网络核心,0,安徽,一般节点,38203\",\r\n        \"0,北京,网络核心,0,山东,网络核心,438314\",\r\n        \"0,北京,网络核心,0,山西,网络核心,29909\",\r\n        \"0,北京,网络核心,0,广东,网络核心,46012\",\r\n        \"0,北京,网络核心,0,广西,一般节点,7439\",\r\n        \"0,北京,网络核心,0,新疆,一般节点,2390\",\r\n        \"0,北京,网络核心,0,江苏,一般节点,55678\",\r\n        \"0,北京,网络核心,0,江西,一般节点,8116\",\r\n        \"0,北京,网络核心,0,河北,网络核心,87662\",\r\n        \"0,北京,网络核心,0,河南,网络核心,62783\",\r\n        \"0,北京,网络核心,0,浙江,一般节点,37425\",\r\n        \"0,北京,网络核心,0,海南,一般节点,144\",\r\n        \"0,北京,网络核心,0,湖北,网络核心,8564\",\r\n        \"0,北京,网络核心,0,湖南,一般节点,4224\",\r\n        \"0,北京,网络核心,0,甘肃,一般节点,584\",\r\n        \"0,北京,网络核心,0,福建,一般节点,52850\",\r\n        \"0,北京,网络核心,0,贵州,一般节点,234\",\r\n        \"0,北京,网络核心,0,辽宁,网络核心,461774\",\r\n        \"0,北京,网络核心,0,重庆,网络核心,5813\",\r\n        \"0,北京,网络核心,0,陕西,网络核心,16090\",\r\n        \"0,北京,网络核心,0,黑龙江,一般节点,33657\",\r\n        \"0,吉林,一般节点,0,内蒙古,一般节点,34084\",\r\n        \"0,吉林,一般节点,0,吉林,一般节点,528602\",\r\n        \"0,吉林,一般节点,0,天津,网络核心,72064\",\r\n        \"0,吉林,一般节点,0,山东,网络核心,984\",\r\n        \"0,吉林,一般节点,0,河北,网络核心,33136\",\r\n        \"0,吉林,一般节点,0,湖北,网络核心,320\",\r\n        \"0,吉林,一般节点,0,辽宁,网络核心,1031729\",\r\n        \"0,吉林,一般节点,0,重庆,网络核心,520\",\r\n        \"0,吉林,一般节点,0,黑龙江,一般节点,82852\",\r\n        \"0,安徽,一般节点,0,上海,网络核心,20781\",\r\n        \"0,安徽,一般节点,0,云南,一般节点,4963\",\r\n        \"0,安徽,一般节点,0,内蒙古,一般节点,13205\",\r\n        \"0,安徽,一般节点,0,吉林,一般节点,9943\",\r\n        \"0,安徽,一般节点,0,四川,网络核心,4024\",\r\n        \"0,安徽,一般节点,0,天津,网络核心,13389\",\r\n        \"0,安徽,一般节点,0,宁夏,一般节点,1514\",\r\n        \"0,安徽,一般节点,0,安徽,一般节点,110534\",\r\n        \"0,安徽,一般节点,0,山东,网络核心,225881\",\r\n        \"0,安徽,一般节点,0,山西,网络核心,35837\",\r\n        \"0,安徽,一般节点,0,广西,一般节点,4905\",\r\n        \"0,安徽,一般节点,0,江苏,一般节点,40904\",\r\n        \"0,安徽,一般节点,0,江西,一般节点,13668\",\r\n        \"0,安徽,一般节点,0,河北,网络核心,39647\",\r\n        \"0,安徽,一般节点,0,河南,网络核心,72111\",\r\n        \"0,安徽,一般节点,0,浙江,一般节点,40600\",\r\n        \"0,安徽,一般节点,0,湖北,网络核心,19974\",\r\n        \"0,安徽,一般节点,0,湖南,一般节点,43237\",\r\n        \"0,安徽,一般节点,0,福建,一般节点,10013\",\r\n        \"0,安徽,一般节点,0,贵州,一般节点,17144\",\r\n        \"0,安徽,一般节点,0,重庆,网络核心,8355\",\r\n        \"0,安徽,一般节点,0,陕西,网络核心,2651\",\r\n        \"0,安徽,一般节点,0,青海,一般节点,1454\",\r\n        \"0,安徽,一般节点,0,黑龙江,一般节点,16149\",\r\n        \"0,广西,一般节点,0,上海,网络核心,2236\",\r\n        \"0,广西,一般节点,0,云南,一般节点,4300\",\r\n        \"0,广西,一般节点,0,内蒙古,一般节点,2341\",\r\n        \"0,广西,一般节点,0,吉林,一般节点,2658\",\r\n        \"0,广西,一般节点,0,四川,网络核心,1611\",\r\n        \"0,广西,一般节点,0,天津,网络核心,3248\",\r\n        \"0,广西,一般节点,0,山东,网络核心,33436\",\r\n        \"0,广西,一般节点,0,山西,网络核心,6819\",\r\n        \"0,广西,一般节点,0,广东,网络核心,208175\",\r\n        \"0,广西,一般节点,0,广西,一般节点,229281\",\r\n        \"0,广西,一般节点,0,江苏,一般节点,2278\",\r\n        \"0,广西,一般节点,0,江西,一般节点,1244\",\r\n        \"0,广西,一般节点,0,河北,网络核心,5654\",\r\n        \"0,广西,一般节点,0,河南,网络核心,74977\",\r\n        \"0,广西,一般节点,0,浙江,一般节点,3370\",\r\n        \"0,广西,一般节点,0,海南,一般节点,4894\",\r\n        \"0,广西,一般节点,0,湖北,网络核心,1581\",\r\n        \"0,广西,一般节点,0,湖南,一般节点,39127\",\r\n        \"0,广西,一般节点,0,甘肃,一般节点,66\",\r\n        \"0,广西,一般节点,0,福建,一般节点,15228\",\r\n        \"0,广西,一般节点,0,贵州,一般节点,25988\",\r\n        \"0,广西,一般节点,0,重庆,网络核心,7064\",\r\n        \"0,广西,一般节点,0,陕西,网络核心,4669\",\r\n        \"0,广西,一般节点,0,青海,一般节点,1107\",\r\n        \"0,广西,一般节点,0,黑龙江,一般节点,6773\",\r\n        \"0,新疆,一般节点,0,山西,网络核心,180\",\r\n        \"0,新疆,一般节点,0,广东,网络核心,120\",\r\n        \"0,新疆,一般节点,0,新疆,一般节点,60\",\r\n        \"0,新疆,一般节点,0,湖南,一般节点,60\",\r\n        \"0,新疆,一般节点,0,陕西,网络核心,606\",\r\n        \"0,辽宁,网络核心,0,上海,网络核心,40207\",\r\n        \"0,辽宁,网络核心,0,云南,一般节点,6056\",\r\n        \"0,辽宁,网络核心,0,内蒙古,一般节点,136690\",\r\n        \"0,辽宁,网络核心,0,四川,网络核心,9084\",\r\n        \"0,辽宁,网络核心,0,天津,网络核心,131444\",\r\n        \"0,辽宁,网络核心,0,安徽,一般节点,54715\",\r\n        \"0,辽宁,网络核心,0,山东,网络核心,401438\",\r\n        \"0,辽宁,网络核心,0,山西,网络核心,104200\",\r\n        \"0,辽宁,网络核心,0,广东,网络核心,91452\",\r\n        \"0,辽宁,网络核心,0,广西,一般节点,32109\",\r\n        \"0,辽宁,网络核心,0,新疆,一般节点,14600\",\r\n        \"0,辽宁,网络核心,0,江苏,一般节点,110478\",\r\n        \"0,辽宁,网络核心,0,江西,一般节点,28746\",\r\n        \"0,辽宁,网络核心,0,河北,网络核心,342698\",\r\n        \"0,辽宁,网络核心,0,河南,网络核心,315568\",\r\n        \"0,辽宁,网络核心,0,浙江,一般节点,31890\",\r\n        \"0,辽宁,网络核心,0,海南,一般节点,9398\",\r\n        \"0,辽宁,网络核心,0,湖北,网络核心,5392\",\r\n        \"0,辽宁,网络核心,0,湖南,一般节点,56296\",\r\n        \"0,辽宁,网络核心,0,福建,一般节点,25682\",\r\n        \"0,辽宁,网络核心,0,贵州,一般节点,6272\",\r\n        \"0,辽宁,网络核心,0,辽宁,网络核心,4939414\",\r\n        \"0,辽宁,网络核心,0,重庆,网络核心,100330\",\r\n        \"0,辽宁,网络核心,0,陕西,网络核心,43398\",\r\n        \"0,辽宁,网络核心,0,青海,一般节点,36596\",\r\n        \"0,辽宁,网络核心,0,黑龙江,一般节点,634194\",\r\n        \"0,重庆,网络核心,0,重庆,网络核心,250036\"\r\n        ]\r\n        constructor(){\r\n            this.isCheckPathNegative = true\r\n            this.typeHeight = ComputeData.typeHeight\r\n            this.format()\r\n            this.merge_Same_Edge()\r\n            this.merge_FT_Edege()\r\n            this.generateTypeEdge()\r\n            this.computeEBResults()\r\n            this.computeNodes()\r\n        }\r\n\r\n        format(){\r\n            let maxValue = 0\r\n            let data = []\r\n            this.NETFLOW_DATA.forEach(line=>{\r\n                let strArr = line.split(\",\")\r\n                let source = strArr[1]\r\n                let source_level = strArr[2] === \"网络核心\" ? \"C\" :\"N\"\r\n                let target = strArr[4]\r\n                let target_level = strArr[5] === \"网络核心\" ? \"C\" :\"N\"\r\n                let value = +strArr[6]\r\n                if(maxValue<value)maxValue = value\r\n\r\n                if(source_level===\"N\" && target_level===\"C\"){//做反转，让核心节点做起点，一般节点做终点\r\n                    let temp_source = source\r\n                    let temp_level = source_level\r\n\r\n                    source = target\r\n                    target = temp_source\r\n\r\n                    source_level = target_level\r\n                    target_level = temp_level\r\n                }\r\n\r\n                data.push({source,source_level,target,target_level,value})\r\n            })\r\n            this.maxValue = maxValue\r\n            this.NETFLOW_DATA = data\r\n        }\r\n        merge_Same_Edge(){\r\n            let maxValue = 0\r\n            let newData = []\r\n            let indexObj = {}\r\n            this.NETFLOW_DATA.forEach(line=>{\r\n               let {source,source_level,target,target_level,value} = line\r\n               let str = source+source_level+target+target_level\r\n               if(indexObj[str] === undefined){\r\n                   indexObj[str] = newData.length\r\n                   newData.push({source,source_level,target,target_level,value})\r\n               }else{\r\n                   let index = indexObj[str]\r\n                   newData[index].value = newData[index].value + value\r\n                   if(maxValue<newData[index].value)maxValue = newData[index].value\r\n               }\r\n            })\r\n            this.maxValue = maxValue\r\n            this.NETFLOW_DATA = newData\r\n        }\r\n\r\n        merge_FT_Edege(){\r\n            let newData = []\r\n            let indexObj = {}\r\n            let maxValue=0\r\n            this.NETFLOW_DATA.forEach(line=>{\r\n                let {source,source_level,target,target_level,value} = line\r\n                let str1 = source+source_level+target+target_level\r\n                let str2 = target+target_level+source+source_level\r\n                if(indexObj[str1]===undefined){\r\n                    indexObj[str1] = indexObj[str2] = newData.length\r\n                    newData.push({source,source_level,target,target_level,value})\r\n                    if(maxValue<value)maxValue = value\r\n                }else{\r\n                    let index = indexObj[str1]\r\n                    newData[index].value = newData[index].value + value\r\n                    if(maxValue < newData[index].value)maxValue=newData[index].value\r\n                }\r\n            })\r\n            this.maxValue = maxValue\r\n            this.NETFLOW_DATA = newData\r\n        }\r\n        generateTypeEdge(){\r\n            this.nodeLevel={}\r\n            let typeEdge = {\"C\":[], \"N\":[], \"CN\":[]}\r\n            this.NETFLOW_DATA.forEach(line=>{\r\n                let {source,source_level,target,target_level,value} = line\r\n                this.nodeLevel[source] = source_level\r\n                this.nodeLevel[target] = target_level\r\n                if(source_level===target_level && source_level===\"C\")typeEdge[\"C\"].push({source,source_level,target,target_level,value})\r\n                if(source_level===target_level && source_level===\"N\")typeEdge[\"N\"].push({source,source_level,target,target_level,value})\r\n                if(source_level!==target_level)typeEdge[\"CN\"].push({source,source_level,target,target_level,value})\r\n            })\r\n\r\n            this.typeEdge = typeEdge\r\n        }\r\n        computeEBResults(){\r\n            let typeEdge = this.typeEdge\r\n            let newType = {\"C\":{\"EB\":[], \"DC\":[], \"Ring\":[]}, \"N\":{\"EB\":[], \"DC\":[], \"Ring\":[]}, \"CN\":{\"EB\":[], \"DC\":[]}}\r\n            for(let attr in typeEdge){\r\n                if(attr.indexOf(\"N\")===1){\r\n                    let nodes={}\r\n                    let links=[]\r\n                    typeEdge[attr].forEach(line=>{\r\n                        let {source,source_level,target,target_level,value} = line\r\n                        let fx = coordinatesData[source].x\r\n                        let fy = coordinatesData[source].y\r\n                        let fz = this.typeHeight[\"A_\"+source_level]\r\n\r\n                        let tx = coordinatesData[target].x\r\n                        let ty = coordinatesData[target].y\r\n                        let tz = this.typeHeight[\"A_\"+target_level]\r\n                        if(source === target)tz=tz+0.0001\r\n                        nodes[source] = {x:fx, y:fy, z:fz}\r\n                        nodes[target] = {x:tx, y:ty, z:tz}\r\n                        links.push({source,target,value})\r\n\r\n                        let path =[[fx,fy,fz],[tx,ty,tz]]\r\n                        let info = source+\"->\"+target+\" \"+\"value:\"+value\r\n                        newType[attr][\"DC\"].push({info,path,value})\r\n                    })\r\n                    // newType[attr][\"EB\"]\r\n                    \r\n                    //let EBdata = KernelEdgeBundling.KernelEdgeBundling3D().nodes(nodes).edges(links)()\r\n\r\n                    let EBdata = KernelEdgeBundling.KernelEdgeBundling3D_ADEB().nodes(nodes).edges(links)()\r\n\r\n                    EBdata.forEach(path=>{\r\n                        let source = path[0].id\r\n                        let target = path[path.length-1].id\r\n                        let value = path[0].value\r\n                        let info = source+\"->\"+target+\" value\"+value\r\n                        let newPath = []\r\n                        path.forEach(obj=>{\r\n                            let {x,y,z} = obj\r\n                            if(this.isCheckPathNegative){\r\n                                x = x > 0 ? x : 0\r\n                                y = y > 0 ? y : 0\r\n                                z = z > 0 ? z : 0\r\n                            }\r\n                            newPath.push([x,y,z])\r\n                        })\r\n                        newType[attr][\"EB\"].push({path:newPath, info, value})\r\n                    })\r\n\r\n                }else{\r\n                    let nodes={}\r\n                    let links=[]\r\n                    typeEdge[attr].forEach(line=>{\r\n                        let {source,source_level,target,target_level,value} = line\r\n                        let fx = coordinatesData[source].x\r\n                        let fy = coordinatesData[source].y\r\n                        let fz = this.typeHeight[\"A_\"+source_level]\r\n\r\n                        let tx = coordinatesData[target].x\r\n                        let ty = coordinatesData[target].y\r\n                        let tz = this.typeHeight[\"A_\"+target_level]\r\n                        if(source!==target){\r\n                            nodes[source] = {x:fx, y:fy}\r\n                            nodes[target] = {x:tx, y:ty}\r\n                            links.push({source,target,value})\r\n\r\n                            let path =[[fx,fy,fz],[tx,ty,tz]]\r\n                            let info = source+\"->\"+target+\" \"+\"value:\"+value\r\n                            newType[attr][\"DC\"].push({info,path,value})\r\n                        }else{\r\n                            newType[attr][\"Ring\"].push({city:source, coordinates:[fx,fy,fz], value})\r\n                        }\r\n\r\n                    })\r\n                    // newType[attr][\"EB\"] \r\n                    let EBdata = KernelEdgeBundling.KernelEdgeBundling2D().nodes(nodes).edges(links)()\r\n                    EBdata.forEach(path=>{\r\n                        let source = path[0].id\r\n                        let target = path[path.length-1].id\r\n                        let value = path[0].value\r\n                        let info = source+\"->\"+target+\" value\"+value\r\n                        let newPath = []\r\n                        path.forEach(obj=>{\r\n                            let {x,y} = obj\r\n                            let z = this.typeHeight[\"A_\"+attr]\r\n                            newPath.push([x,y,z])\r\n                        })\r\n                        newType[attr][\"EB\"].push({path:newPath, info, value})\r\n                    })\r\n\r\n                }\r\n            }\r\n\r\n            this.typeEdge = newType\r\n        }\r\n        computeNodes(){\r\n            let nodesValue = {}\r\n            for(let attr1 in this.typeEdge){\r\n                for(let attr2 in this.typeEdge[attr1]){\r\n                    let path = this.typeEdge[attr1][attr2]\r\n                    if(attr2!==\"Ring\"){\r\n                        path.forEach(line=>{\r\n                            let from = line.info.split(\" \")[0].split(\"->\")[0]\r\n                            let to = line.info.split(\" \")[0].split(\"->\")[1]\r\n                            let value = line.value\r\n                            let from_coordinates = line.path[0]\r\n                            let to_coordinates = line.path[line.path.length -1]\r\n                            nodesValue[from] = nodesValue[from] === undefined ? {} : nodesValue[from]\r\n                            nodesValue[from].value= nodesValue[from].value===undefined ? value : nodesValue[from].value+value\r\n                            nodesValue[from].fillColor = this.nodeLevel[from] === \"C\" ? [255,0,0] : [0,0,255]\r\n                            nodesValue[from].coordinates = [...from_coordinates]\r\n\r\n                            nodesValue[to] = nodesValue[to] === undefined ? {} : nodesValue[to]\r\n                            nodesValue[to].value= nodesValue[to].value===undefined ? value : nodesValue[to].value+value\r\n                            nodesValue[to].fillColor = this.nodeLevel[to] === \"C\" ? [255,0,0] : [0,0,255]\r\n                            nodesValue[to].coordinates = [...to_coordinates]\r\n                        })\r\n                    }else{\r\n                        path.forEach(line=>{\r\n                            let {city, value} = line\r\n                            nodesValue[city] = nodesValue[city] === undefined ? {} :nodesValue[city]\r\n                            nodesValue[city].value = nodesValue[city].value===undefined ? value : nodesValue[city].value +value\r\n                            nodesValue[city].coordinates = [...line.coordinates]\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n            //查找最大值\r\n            let maxNodeVlue =0\r\n            for(let attr in nodesValue){\r\n                maxNodeVlue = maxNodeVlue<nodesValue[attr].value ? nodesValue[attr].value : maxNodeVlue \r\n            }\r\n            this.maxNodeVlue = maxNodeVlue\r\n            //设置半径\r\n            for(let attr in nodesValue){\r\n                nodesValue[attr].radius = this.getRadius(nodesValue[attr].value)\r\n            }\r\n            this.nodes = nodesValue\r\n        }\r\n        getResults(){\r\n            let results = {\"DC\":[], \"EB\":[], \"Ring\":[]}\r\n            results[\"DC\"]=[...this.typeEdge[\"C\"][\"DC\"], ...this.typeEdge[\"N\"][\"DC\"], ...this.typeEdge[\"CN\"][\"DC\"]]\r\n            results[\"EB\"]=[...this.typeEdge[\"C\"][\"EB\"], ...this.typeEdge[\"N\"][\"EB\"], ...this.typeEdge[\"CN\"][\"EB\"]]\r\n            results[\"Ring\"]=[...this.typeEdge[\"C\"][\"Ring\"], ...this.typeEdge[\"N\"][\"Ring\"]]\r\n            for(let attr in results){\r\n                results[attr].forEach(line=>{\r\n                    line.color = this.getColor(line.value,this.maxValue,50)\r\n                })\r\n            }\r\n\r\n            this.results = results\r\n            let nodes = this.nodes\r\n            let newResults = {edge:results, nodes}\r\n            console.log(\"netflow:\",newResults)\r\n            return newResults\r\n        }\r\n        getRadius(value){\r\n            let maxRadius = 4\r\n            let minRadius = 2\r\n            let maxNodeVlue = this.maxNodeVlue\r\n            let t = value / maxNodeVlue *10\r\n            if(t>1) t=1\r\n            return ((maxRadius-minRadius)*t+minRadius)\r\n        }\r\n\r\n        getColor(value, maxValue, k){\r\n            let t = value / maxValue * k\r\n            if(t>1) t=1\r\n    \r\n            let g = d3.rgb(0,255,128)\r\n            let b = d3.rgb(0,0,255)\r\n            let g2b = d3.interpolate(g,b)\r\n            let rgbArr = g2b(t).replace(\"rgb(\",\"\").replace(\")\",\"\").split(\",\")\r\n    \r\n            return [parseInt(rgbArr[0]),parseInt(rgbArr[1]),parseInt(rgbArr[2])]\r\n        }\r\n        isCheckPathNegative(isCheckPathNegative){\r\n            this.isCheckPathNegative = isCheckPathNegative===undefined ? true : isCheckPathNegative\r\n        }\r\n}","import React, { Component } from 'react'\r\nimport DeckGL from '@deck.gl/react'\r\nimport { OrbitView } from \"@deck.gl/core\"\r\nimport PubSub from \"pubsub-js\"\r\n\r\nexport default class Map extends Component {\r\n    static allLayers = {}\r\n    static currentScatterData = {A:[], B:[]}\r\n    static currentEdgeData = {A:[], B:[]}\r\n    static currentDataKind = \"traffic\"\r\n    constructor(props){\r\n        super(props)\r\n        this.state = {\r\n            layers:[]\r\n        }\r\n\r\n        this.INITIAL_VIEW_STATE = {\r\n            target: [965.7479834999999, 300.012138, 0],\r\n            zoom: 1,\r\n            rotationOrbit: 0,\r\n            rotationX: 40,\r\n            minRotationX: -90,\r\n            maxRotationX: 90,\r\n            minZoom: -10,\r\n            maxZoom: 10\r\n        }\r\n\r\n        let changeMapLayers = this.changeMapLayers\r\n        PubSub.publish(\"changeMapLayers\", {changeMapLayers})\r\n    }\r\n\r\n    changeMapLayers = (layers)=>{\r\n        this.setState({layers})\r\n    }\r\n\r\n    componentDidMount(){\r\n        //当Map组件挂载上后，通知Topnav组件，让它根据当前buttonState更新layers\r\n        PubSub.publish(\"MapDidMount\", {DidMount:true})\r\n    }\r\n\r\n    render(){\r\n        const { layers } = this.state\r\n        let style = {\r\n            top:\"125px\",\r\n            left:\"50px\",\r\n            width:\"70%\",\r\n            height:\"120%\",\r\n        }\r\n        return (\r\n            <DeckGL\r\n            views={new OrbitView({\r\n                orbitAxis: 'Z',\r\n            })}\r\n            initialViewState={this.INITIAL_VIEW_STATE}\r\n            controller={true}\r\n            layers={[...layers]}\r\n            style = {style}\r\n            id=\"deckGL\"\r\n        />\r\n        )\r\n    }\r\n}","\r\nimport { LineLayer, PathLayer, ScatterplotLayer, TextLayer, PolygonLayer } from '@deck.gl/layers'\r\nimport PubSub from \"pubsub-js\"\r\nimport Map from './index'\r\nimport Topnav from \"../../../topnav/index\"\r\n\r\nexport default class Layer{\r\n    constructor(){\r\n        this.receiveDataInfo()\r\n        this.receiveButtonInfo()\r\n        this.receiveChangeMapLayers()\r\n        Layer.updateHighlightPoint_Edge = this.updateHighlightPoint_Edge.bind(this)\r\n        Layer.cancelHighlight = this.cancelHighlight.bind(this)\r\n        Layer.updateHighlightEdge = this.updateHighlightEdge.bind(this)\r\n    }\r\n    //接收来自其他组件的信息\r\n    receiveButtonInfo = ()=>{\r\n        PubSub.subscribe('button', (_, stateObj) => {// {dataKind, edgeKind, plane, netflow }\r\n            let {button} = stateObj\r\n            this.buttonState = button\r\n            console.log(\"接收到了消息\",button)\r\n        });\r\n        this.buttonState = Topnav.state\r\n    }\r\n\r\n    receiveDataInfo = ()=>{\r\n        PubSub.subscribe('data', (_, stateObj) => {// {dataKind, edgeKind, plane, netflow }\r\n            let {results, netflowResults} = stateObj\r\n            this.results = results\r\n            this.netflowResults = netflowResults\r\n        });\r\n    }\r\n\r\n    receiveChangeMapLayers=()=>{\r\n        PubSub.subscribe('changeMapLayers', (_, stateObj) => {\r\n            let {changeMapLayers} = stateObj\r\n            this.changeMapLayers = changeMapLayers\r\n        });\r\n    }\r\n\r\n\r\n    //生成layer的部分\r\n    getPathLayer = (paramObj) => {//PathLayer需要d.path, d.color\r\n        let {data, layerID, opacity, filter2D} = paramObj\r\n        //过滤2D\r\n        if(filter2D)data = this.filter2D(data)\r\n        opacity = opacity === undefined ? 0.2 : opacity\r\n        return new PathLayer({\r\n            id: layerID,\r\n            data: [...data],\r\n            pickable: true,\r\n            widthScale: 1,\r\n            widthMinPixels: 0.1,\r\n            widthMaxPixels: 3,\r\n            getPath: d => { return d.path },\r\n            getColor: d => d.color,\r\n            getWidth: d => { return d.width },\r\n            opacity: opacity,\r\n            billboard: true,\r\n            autoHighlight: true,\r\n            highlightColor: [255, 0, 0],\r\n            onClick: (d) => { this.showInfo(d) }//this.convertEdge(d)  this.showInfo(d)\r\n        });\r\n    }\r\n\r\n    getScatterPlotLayer = (paramObj) => {//ScatterPlotLayer需要d.fillColor, d.position, d.radius,\r\n        let {data, layerID} = paramObj\r\n        return new ScatterplotLayer({\r\n            id: layerID,\r\n            data: [...data],\r\n            getFillColor: d => d.fillColor,\r\n            getLineColor: [0, 0, 0],\r\n            getPosition: d => d.position,//[a[0]*6, a[1]*4,a[2]]},//{ return [...d.xyz] },\r\n            getRadius: d => { return d.radius },\r\n            lineWidthMinPixels: 0,\r\n            radiusMaxPixels: 100,\r\n            radiusMinPixels: 1,\r\n            radiusScale: 1,\r\n            stroked: false,\r\n            opacity: 1,\r\n            pickable: true,\r\n            autoHighlight: true,\r\n            highlightColor: [0, 255, 0],\r\n            onHover: (info) => this.highlightPoint_Edge(info),\r\n            onClick: (d,event) => {this.clickScatter(d, event)}\r\n        })\r\n    }\r\n\r\n    getTextLayer = (paramObj) => {//TextLayer需要d.position, d.name\r\n        let {data, layerID} = paramObj\r\n        return new TextLayer({\r\n            id: layerID,\r\n            data: [...data],\r\n            pickable: false,\r\n            getPosition: d => { let a = d.position; return [a[0], a[1], a[2] + 2] },\r\n            getText: d => { return d.info.split(\",\")[0] },\r\n            characterSet: \"auto\",\r\n            getSize: 10,\r\n            getAngle: 0,\r\n            sizeScale: 1.2,\r\n            sizeMinPixels: 10,\r\n            //sizeMaxPixels:1,\r\n            getTextAnchor: 'middle',\r\n            getAlignmentBaseline: 'center'\r\n        });\r\n    }\r\n\r\n    getPolygonLayer = (paramObj) => {\r\n        let {data, layerID, color} = paramObj\r\n        return new PolygonLayer({\r\n            id: layerID,\r\n            data: data,\r\n            pickable: false,\r\n            stroked: false,\r\n            filled: true,\r\n            wireframe: true,\r\n            lineWidthMinPixels: 1,\r\n            getPolygon: d => d.contour,\r\n            getFillColor: color,\r\n            getLineColor: [80, 80, 80],\r\n            getLineWidth: 0,\r\n            opacity: 1\r\n        })\r\n    }\r\n\r\n    getRingLayer = (paramObj) => {\r\n        let {data, layerID, color} = paramObj\r\n        return new PolygonLayer({\r\n            id: layerID,\r\n            data: data,\r\n            pickable: true,\r\n            stroked: true,\r\n            filled: true,\r\n            wireframe: true,\r\n            lineWidthMinPixels: 1,\r\n            getPolygon: d => d.contour,\r\n            //getElevation: d => d.population / d.area / 10,\r\n            getFillColor: [255, 255, 0],\r\n            getLineColor: [255, 255, 0],\r\n            getLineWidth: 1,\r\n            opacity: 1\r\n        })\r\n    }\r\n\r\n    //交互部分\r\n    showInfo = (event) => {\r\n        let info = event.object.info\r\n        info.replace(\"->\", \"<-->\")\r\n        alert(String(info))\r\n    }\r\n\r\n    filter2D = (data) => {//是否过滤2D平面的数据\r\n        let newData = []\r\n        data.forEach(line => {\r\n            let path = line.path\r\n            if (path[0][2] !== path[path.length - 1][2]) {\r\n                newData.push(line)\r\n            }\r\n        })\r\n        return newData\r\n    }\r\n\r\n    preState = false//记录该点是否获取到鼠标焦点\r\n    highlightPoint_Edge = (info) => {\r\n        let netflow = this.buttonState.netflow\r\n        if(netflow.exist)return null\r\n        if (info.picked && !this.preState) {\r\n            this.preState = true\r\n            let scatterInfo = info.object.info\r\n            this.updateHighlightPoint_Edge(scatterInfo)\r\n        }\r\n        if (!info.picked && this.preState) {\r\n            this.preState = false\r\n            this.cancelHighlight()\r\n        }\r\n    }\r\n\r\n    updateHighlightPoint_Edge(scatterInfo, from) {\r\n        const { DC, EB } = this.results\r\n        let dataKind = this.buttonState.dataKind.traffic ? \"traffic\" : \"bd\"\r\n        let plane = !this.buttonState.plane.A ? (!this.buttonState.plane.B ? \"\" : \"B\") : (!this.buttonState.plane.B ? \"A\" : \"AB\")\r\n        let edgeKind = this.buttonState.edgeKind.EB ? \"EB\" : \"DC\"\r\n        let myData = edgeKind === \"EB\" ? EB : DC\r\n        if (plane === \"\") { return true }\r\n        let data = myData[plane + \"_\" + dataKind]\r\n        if(data === undefined){console.log(\"data出现问题\",plane + \"_\" + dataKind)}\r\n        let highlightEdges = []\r\n        let highlightScatter = []\r\n        let ScatterObj = {}\r\n        data.forEach(line=>{\r\n            let info = line.info\r\n            if(info.indexOf(scatterInfo)>-1){\r\n                let {info, path, value, width} = line\r\n                highlightEdges.push({color:[255,0,0], info, path, value, width})\r\n                let cityArr = info.split(\" \")[0].split(\"->\")\r\n                let source = cityArr[0], target = cityArr[1]\r\n                ScatterObj[source] = true\r\n                ScatterObj[target] = true\r\n            }\r\n        })\r\n        \r\n        Topnav.scatterData[dataKind].forEach(line=>{\r\n            if(ScatterObj[line.info]===true){\r\n                let {info, radius, value} = line\r\n                let position = [...line.position]\r\n                let fillColor = [255,105,180]\r\n                if(line.info===scatterInfo)fillColor = [0, 255, 0]\r\n                highlightScatter.push({fillColor, info, position, radius, value})\r\n            }\r\n        })\r\n        let pathLayerParamObj = {data: highlightEdges, layerID: \"highlightLayer\", opacity: 0.5, filter2D: false}\r\n        let pathLayer = this.getPathLayer(pathLayerParamObj)\r\n        Map.allLayers[\"highlightPahtLayers\"] = [pathLayer]\r\n        \r\n        let scatterLayerParamObj ={data: highlightScatter, layerID: \"highlightScatter\"}\r\n        let scatterLayer = this.getScatterPlotLayer(scatterLayerParamObj)\r\n        Map.allLayers[\"highlightScatterLayers\"] = [scatterLayer]\r\n        this.combineLayers()\r\n    }\r\n\r\n    updateHighlightEdge=(edgeInfo)=>{\r\n        const { DC, EB } = this.results\r\n        let dataKind = this.buttonState.dataKind.traffic ? \"traffic\" : \"bd\"\r\n        let plane = !this.buttonState.plane.A ? (!this.buttonState.plane.B ? \"\" : \"B\") : (!this.buttonState.plane.B ? \"A\" : \"AB\")\r\n        let edgeKind = this.buttonState.edgeKind.EB ? \"EB\" : \"DC\"\r\n        let myData = edgeKind === \"EB\" ? EB : DC\r\n        if (plane === \"\") { return true }\r\n        let data = myData[plane + \"_\" + dataKind]\r\n        if(data === undefined){console.log(\"data出现问题\",plane + \"_\" + dataKind)}\r\n        let highlightEdges = []\r\n        let highlightScatter = []\r\n        let ScatterObj = {}\r\n        data.forEach(line=>{\r\n            let info = line.info\r\n            if(info.indexOf(edgeInfo)>-1){\r\n                let {info, path, value, width} = line\r\n                highlightEdges.push({color:[255,0,0], info, path, value, width})\r\n                let cityArr = info.split(\" \")[0].split(\"->\")\r\n                let source = cityArr[0], target = cityArr[1]\r\n                ScatterObj[source] = true\r\n                ScatterObj[target] = true\r\n            }\r\n        })\r\n\r\n        Topnav.scatterData[dataKind].forEach(line=>{\r\n            if(ScatterObj[line.info]===true){\r\n                let {info, radius, value} = line\r\n                let position = [...line.position]\r\n                let fillColor = [0, 255, 0]\r\n                highlightScatter.push({fillColor, info, position, radius, value})\r\n            }\r\n        })\r\n        let pathLayerParamObj = {data: highlightEdges, layerID: \"highlightLayer\", opacity: 0.5, filter2D: false}\r\n        let pathLayer = this.getPathLayer(pathLayerParamObj)\r\n        Map.allLayers[\"highlightPahtLayers\"] = [pathLayer]\r\n        \r\n        let scatterLayerParamObj ={data: highlightScatter, layerID: \"highlightScatter\"}\r\n        let scatterLayer = this.getScatterPlotLayer(scatterLayerParamObj)\r\n        Map.allLayers[\"highlightScatterLayers\"] = [scatterLayer]\r\n        this.combineLayers()\r\n    }\r\n\r\n    cancelHighlight=()=>{\r\n        Map.allLayers[\"highlightPahtLayers\"] = []\r\n        Map.allLayers[\"highlightScatterLayers\"] = []\r\n        this.combineLayers()\r\n    }\r\n\r\n    combineLayers = ()=>{\r\n        let layers = []\r\n        //先放pathLayer，再放netflowLayer，再放ringLayer\r\n        layers=[...Map.allLayers.pathLayers, ...Map.allLayers.netflowLayers, ...Map.allLayers.ringLayers, ...Map.allLayers.scatterLayers]\r\n        //再放highlightLayer\r\n        for(let attr in Map.allLayers){\r\n            if(attr.indexOf(\"highlight\")>-1){\r\n                layers = [...layers, ...Map.allLayers[attr]]\r\n            }\r\n        }\r\n        //再放rightClickLayer\r\n        for(let attr in this.rightClickLayers){\r\n            if(this.rightClickLayers[attr] !== null){\r\n                layers.push(this.rightClickLayers[attr])\r\n            }\r\n        }\r\n        layers = [...layers, ...Map.allLayers[\"textLayers\"], ...Map.allLayers[\"polygonLayers\"]]\r\n        this.changeMapLayers(layers)        \r\n    }\r\n\r\n    rightClickScatter = {}\r\n    rightClickLayers = {}\r\n    clickScatter = (d,event)=>{\r\n        if(event.leftButton){\r\n            alert(d.object.info + \" 流量：\" + String(d.object.value))\r\n        }else{\r\n            let scatterID = d.object.info\r\n            if(this.rightClickScatter[scatterID] === undefined) this.rightClickScatter[scatterID] = false\r\n            this.rightClickScatter[scatterID] = !this.rightClickScatter[scatterID]//如果是false，那么就取消跟这个点相关的线，如果是true，那么就显示跟这个点相关的线\r\n            if(!this.rightClickScatter[scatterID]){\r\n                this.rightClickLayers[scatterID] = null\r\n                this.combineLayers()\r\n                return true\r\n            }\r\n            let edgeKind = this.buttonState.edgeKind.EB ? \"EB\" : \"DC\"\r\n            if(this.buttonState.edgeKind.EB && this.buttonState.edgeKind.DC)return null\r\n            const {DC, EB} = this.results;\r\n            let dataKind = this.buttonState.dataKind.traffic ? \"traffic\" : \"bd\"\r\n            let plane = !this.buttonState.plane.A ? (!this.buttonState.plane.B ? \"\" : \"B\") : (!this.buttonState.plane.B ? \"A\" : \"AB\")\r\n            if (plane === \"\") { return true }\r\n            let myData = edgeKind === \"EB\" ? DC : EB\r\n            let data = myData[plane + \"_\" + dataKind]\r\n            let edgesData = []\r\n            data.forEach(line=>{\r\n                let {info} = line\r\n                if(info.indexOf(scatterID)>-1)edgesData.push(line)\r\n            })\r\n            let pathLayerParamObj = {data: edgesData, layerID: \"rightClick\"+String(scatterID)}\r\n            let layer = this.getPathLayer(pathLayerParamObj)\r\n            this.rightClickLayers[scatterID] = layer\r\n            this.combineLayers()\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}","import React, { Component } from 'react'\r\nimport \"./index.css\"\r\nimport PubSub from \"pubsub-js\"\r\nimport Layer from '../row/leftColumn/map/Layer'\r\nimport Map from '../row/leftColumn/map'\r\nimport ComputeData from '../row/leftColumn/map/ComputeData'\r\n\r\nexport default class Topnav extends Component {\r\n    static scatterData = { bd: [], traffic: [] }\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            dataKind: {\r\n                traffic: true,\r\n                bd: false\r\n            },\r\n            edgeKind: {\r\n                EB: false,\r\n                DC: true\r\n            },\r\n            plane: {\r\n                A: true,\r\n                B: true\r\n            },\r\n            netflow: { exist: false }\r\n        }\r\n        //接收来自data的信息\r\n        this.receiveDataInfo()\r\n        //接收来自Map的信息\r\n        this.receiveChangeMapLayers()\r\n        //把button的状态信息发送出去\r\n        //this.sendButtonStateInfo()\r\n        Topnav.state = this.state\r\n        //接收map是否挂载完毕\r\n        this.receiveMapDidMount()\r\n        this.receiveRightInfo()\r\n        this.layer = new Layer()\r\n\r\n    }\r\n\r\n    receiveRightInfo = () => {\r\n        PubSub.subscribe('rightDataKind', (_, stateObj) => {\r\n            let { setDataKind } = stateObj\r\n            this.setRightColumnDataKind = setDataKind\r\n        });\r\n    }\r\n\r\n    receiveChangeMapLayers = () => {\r\n        PubSub.subscribe('changeMapLayers', (_, stateObj) => {\r\n            let { changeMapLayers } = stateObj\r\n            this.changeMapLayers = changeMapLayers\r\n        });\r\n    }\r\n\r\n    receiveDataInfo = () => {\r\n        PubSub.subscribe('data', (_, stateObj) => {// {dataKind, edgeKind, plane, netflow }\r\n            let { results, netflowResults } = stateObj\r\n            this.results = results\r\n            this.netflowResults = netflowResults\r\n            //获取node的traffic和bd的最大值\r\n            let allNodes = results.allNodes\r\n            let maxNodeTraffic = 0, maxNodeBd = 0\r\n            for (let attr in allNodes) {\r\n                let node = allNodes[attr]\r\n                let { traffic, bdUtilization } = node\r\n                if (traffic > maxNodeTraffic) maxNodeTraffic = traffic\r\n                if (bdUtilization > maxNodeBd) maxNodeBd = bdUtilization\r\n            }\r\n            this.maxNodeBd = maxNodeBd\r\n            this.maxNodeTraffic = maxNodeTraffic\r\n        });\r\n    }\r\n\r\n    receiveMapDidMount = () => {\r\n        PubSub.subscribe('MapDidMount', (_, stateObj) => {// {dataKind, edgeKind, plane, netflow }\r\n            let { DidMount } = stateObj\r\n            if (DidMount) {\r\n                this.computeLayers()\r\n                this.combineLayers()\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n\r\n    getButtonColor = (id) => {\r\n        let highlightColor = \"#44ffff\"\r\n        let deHighlightColor = \"#ffffff\"\r\n        let { dataKind, edgeKind, plane, netflow } = this.state\r\n        let color\r\n        if (id === \"traffic\" || id === \"bd\") {\r\n            color = dataKind[id] ? highlightColor : deHighlightColor\r\n\r\n        } else if (id === \"EB\" || id === \"DC\") {\r\n            color = edgeKind[id] ? highlightColor : deHighlightColor\r\n        } else if (id === \"A\" || id === \"B\") {\r\n            color = plane[id] ? highlightColor : deHighlightColor\r\n        } else {//netflow\r\n            color = netflow.exist ? highlightColor : deHighlightColor\r\n        }\r\n        return color\r\n    }\r\n\r\n    updateButtonState = (id) => {\r\n        return () => {\r\n            let { dataKind, edgeKind, plane, netflow } = this.state\r\n            if (id === \"traffic\" || id === \"bd\") {\r\n                let other = id === \"traffic\" ? \"bd\" : \"traffic\"\r\n                dataKind[other] = !dataKind[other]\r\n                dataKind[id] = !dataKind[id]\r\n                this.setState({ dataKind })\r\n            } else if (id === \"EB\" || id === \"DC\") {\r\n                edgeKind[id] = !edgeKind[id]\r\n                this.setState({ edgeKind })\r\n            } else if (id === \"A\" || id === \"B\") {\r\n                plane[id] = !plane[id]\r\n                this.setState({ plane })\r\n            } else {//netflow\r\n                netflow.exist = !netflow.exist\r\n                this.setState({ netflow })\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    computeLayers = () => {\r\n        //清空\r\n        Map.allLayers = {}\r\n        Topnav.scatterData = { bd: [], traffic: [] }\r\n        Map.currentEdgeData = []\r\n        Map.currentScatterData = []\r\n\r\n        let { dataKind, edgeKind, plane, netflow } = this.state\r\n\r\n        Map.currentDataKind = dataKind\r\n\r\n        //保存当前选了几种边的类型\r\n        let edgeKindArr = []\r\n        if (edgeKind.EB) edgeKindArr.push(\"EB\")\r\n        if (edgeKind.DC) edgeKindArr.push(\"DC\")\r\n        //如果没有选边的类型，那么就什么东西都不显示\r\n        if (edgeKindArr.length === 0) return true\r\n\r\n        //保存当前选中的dataKind\r\n        let currentDataKind = dataKind.traffic ? \"traffic\" : \"bd\"\r\n\r\n        let currentPlane = plane.A ? (plane.B ? \"AB\" : \"A\") : (plane.B ? \"B\" : \"\")\r\n\r\n        Topnav.currentPlane = currentPlane\r\n\r\n        //0. 保存节点信息\r\n        this.scatterSet = new Set()\r\n\r\n        //1. 生成 pathLayer\r\n        let pathLayers = []\r\n        Map.allLayers[\"pathLayers\"] = pathLayers\r\n        if (currentPlane === \"\") {//如果没有选平面\r\n            //不执行任何操作，pathLayers是空的\r\n        }\r\n        else {\r\n            edgeKindArr.forEach(edgeKind => {//可能直连和边邦定，两种边类型同时存在\r\n                let edgeKindData = this.results[edgeKind]\r\n                let attr = currentPlane + \"_\" + currentDataKind\r\n                let data = edgeKindData[attr]\r\n                Map.currentEdgeData = [...Map.currentEdgeData, data]\r\n                let layerID = edgeKind + \"_\" + attr\r\n                let pathLayerParamObj = { data, layerID }\r\n                let pathLayer = this.layer.getPathLayer(pathLayerParamObj)\r\n                pathLayers.push(pathLayer)\r\n                //计算pathLayers中的节点\r\n                this.computeScatterData(data)\r\n            });\r\n        }\r\n\r\n        //2. 生成 netflowLayers\r\n        if(netflow.exist){\r\n            Topnav.netflowExist = true\r\n        }else{\r\n            Topnav.netflowExist = false\r\n        }\r\n        let netflowLayers = []\r\n        Map.allLayers[\"netflowLayers\"] = netflowLayers\r\n        if (netflow.exist) {\r\n            //生成EB的pathlayer\r\n            if (edgeKind.EB) {\r\n                let data = this.netflowResults.edge[\"EB\"]\r\n                let layerID = \"netflow_EB\"\r\n                let pathLayerParamObj = { data, layerID }\r\n                netflowLayers.push(this.layer.getPathLayer(pathLayerParamObj))\r\n            }\r\n            //生成DC的pathlayer\r\n            if (edgeKind.DC) {\r\n                let data = this.netflowResults.edge[\"DC\"]\r\n                let layerID = \"netflow_DC\"\r\n                let pathLayerParamObj = { data, layerID }\r\n                netflowLayers.push(this.layer.getPathLayer(pathLayerParamObj))\r\n            }\r\n            //向节点中加入netflow的节点信息\r\n            let nodes = this.netflowResults.nodes\r\n            for (let attr in nodes) {\r\n                if (!this.scatterSet.has(attr)) {\r\n                    let position = nodes[attr].coordinates\r\n                    let value = nodes[attr].value\r\n                    let radius = nodes[attr].radius\r\n                    let fillColor = nodes[attr].fillColor\r\n                    Topnav.scatterData[currentDataKind].push({ info: attr, position, value, radius, fillColor })\r\n                }\r\n            }\r\n        }\r\n        //3.计算netflow的自环，也就是ringLayer\r\n        let ringLayers = []\r\n        Map.allLayers[\"ringLayers\"] = ringLayers\r\n        let ringID = 0\r\n        if (netflow.exist) {\r\n            this.netflowResults[\"edge\"][\"Ring\"].forEach(line => {//改进：先得到所有的ringData，然后用一个Layer画出来\r\n                let { city, color, coordinates, value } = line\r\n                let radius = this.netflowResults[\"nodes\"][city][\"radius\"] * 1.5\r\n                let z = coordinates[2]\r\n                let x0 = coordinates[0] - radius\r\n                let y0 = coordinates[1] - radius\r\n\r\n                let x1 = coordinates[0] + radius\r\n                let y1 = coordinates[1] - radius\r\n\r\n                let x2 = coordinates[0] + radius\r\n                let y2 = coordinates[1] + radius\r\n\r\n                let x3 = coordinates[0] - radius\r\n                let y3 = coordinates[1] + radius\r\n\r\n                let polygonData = [{ contour: [[x0, y0, z], [x1, y1, z], [x2, y2, z], [x3, y3, z], [x0, y0, z]] }]\r\n                let data = polygonData\r\n                let layerID = \"ring\" + ringID\r\n                let paramObj = { data, layerID }\r\n                ringLayers.push(this.layer.getRingLayer(paramObj))\r\n                ringID++\r\n            })\r\n        }\r\n\r\n        //4.计算 ScatterLayer和 TextLayer\r\n        Map.currentScatterData = [...Topnav.scatterData[currentDataKind]]//保存当前的scatterData\r\n        let scatterParamObj = { data: Topnav.scatterData[currentDataKind], layerID: \"scatter-plot\" }\r\n        let scatterLayer = this.layer.getScatterPlotLayer(scatterParamObj)\r\n        Map.allLayers[\"scatterLayers\"] = [scatterLayer]\r\n        let textParamObj = { data: Topnav.scatterData[currentDataKind], layerID: \"text\" }\r\n        let textLayer = this.layer.getTextLayer(textParamObj)\r\n        Map.allLayers[\"textLayers\"] = [textLayer]\r\n\r\n        //5.计算2D半透明平面的数据\r\n        let polygonArr = []\r\n        Map.allLayers[\"polygonLayers\"] = polygonArr\r\n        let minX = 1000000, maxX = 0\r\n        let minY = 1000000, maxY = 0\r\n        Topnav.scatterData[currentDataKind].forEach(line => {\r\n            let x = line.position[0]\r\n            let y = line.position[1]\r\n            if (minX > x) minX = x\r\n            if (maxX < x) maxX = x\r\n            if (minY > y) minY = y\r\n            if (maxY < y) maxY = y\r\n        })\r\n        let A0 = ComputeData.typeHeight[\"A_N\"]\r\n        let A1 = ComputeData.typeHeight[\"A_C\"]\r\n        let B0 = ComputeData.typeHeight[\"B_C\"]\r\n        let B1 = ComputeData.typeHeight[\"B_N\"]\r\n        let polygonData0 = [{ contour: [[minX, minY, A0], [minX, maxY, A0], [maxX, maxY, A0], [maxX, minY, A0], [minX, minY, A0]] }]\r\n        let polygonData1 = [{ contour: [[minX, minY, A1], [minX, maxY, A1], [maxX, maxY, A1], [maxX, minY, A1], [minX, minY, A1]] }]\r\n        let polygonData2 = [{ contour: [[minX, minY, B0], [minX, maxY, B0], [maxX, maxY, B0], [maxX, minY, B0], [minX, minY, B0]] }]\r\n        let polygonData3 = [{ contour: [[minX, minY, B1], [minX, maxY, B1], [maxX, maxY, B1], [maxX, minY, B1], [minX, minY, B1]] }]\r\n        const normalPlaneColor = [0, 0, 255, 10]\r\n        const corePlaneColor = [255, 0, 0, 10]\r\n        //怎么计算有哪些平面 ？ （肯定有edgeKind，为 DC 或 EB）\r\n        //1. 先看pathLayers，也就是看currentPlane为 A， B ，还是 AB 或者 \"\"\r\n        //2. 再看netflow， 如果netflow为true，那么必然有A平面\r\n        let hasA = false, hasB = false\r\n        if (currentPlane.indexOf(\"A\") > -1) hasA = true\r\n        if (currentPlane.indexOf(\"B\") > -1) hasB = true\r\n        if (netflow.exist) hasA = true\r\n        if (hasA) {\r\n            let polygonLayerID0 = { data: polygonData0, layerID: \"p0\", color: normalPlaneColor }\r\n            let polygonLayerID1 = { data: polygonData1, layerID: \"p1\", color: corePlaneColor }\r\n            polygonArr.push(this.layer.getPolygonLayer(polygonLayerID0))\r\n            polygonArr.push(this.layer.getPolygonLayer(polygonLayerID1))\r\n        }\r\n        if (hasB) {\r\n            let polygonLayerID2 = { data: polygonData2, layerID: \"p2\", color: corePlaneColor }\r\n            let polygonLayerID3 = { data: polygonData3, layerID: \"p3\", color: normalPlaneColor }\r\n            polygonArr.push(this.layer.getPolygonLayer(polygonLayerID2))\r\n            polygonArr.push(this.layer.getPolygonLayer(polygonLayerID3))\r\n        }\r\n        return true\r\n    }\r\n\r\n    combineLayers = () => {\r\n        let layers = []\r\n        //先放pathLayer，再放netflowLayer，再放ringLayer\r\n        if (Map.allLayers.pathLayers === undefined) Map.allLayers.pathLayers = []\r\n        if (Map.allLayers.netflowLayers === undefined) Map.allLayers.netflowLayers = []\r\n        if (Map.allLayers.ringLayers === undefined) Map.allLayers.ringLayers = []\r\n        if (Map.allLayers.scatterLayers === undefined) Map.allLayers.scatterLayers = []\r\n        if (Map.allLayers.textLayers === undefined) Map.allLayers.textLayers = []\r\n        if (Map.allLayers.polygonLayers === undefined) Map.allLayers.polygonLayers = []\r\n\r\n\r\n        layers = [...Map.allLayers.pathLayers,\r\n        ...Map.allLayers.netflowLayers,\r\n        ...Map.allLayers.ringLayers,\r\n        ...Map.allLayers.scatterLayers,\r\n        ...Map.allLayers[\"textLayers\"],\r\n        ...Map.allLayers[\"polygonLayers\"],\r\n        ]\r\n        this.changeMapLayers(layers)\r\n    }\r\n\r\n    computeScatterData = (data) => {//有空时把这部分放到 computeData 这个类里，从而实现数据从后端全部计算好，前端减少计算，直接拿来用\r\n        let getScatterRadius = (value, kind) => {\r\n            let maxRadius = 8\r\n            let minRadius = 2\r\n            if (kind === \"traffic\") {\r\n                let t = value / this.maxNodeTraffic * 10\r\n                t = t > 1 ? 1 : t\r\n                let radius = parseInt((maxRadius - minRadius) * t + minRadius)\r\n                return radius\r\n            } else {\r\n                let t = value / this.maxNodeBd * 10\r\n                t = t > 1 ? 1 : t\r\n                let radius = (maxRadius - minRadius) * t + minRadius\r\n                return radius\r\n            }\r\n        }\r\n        let { allNodes } = this.results\r\n        data.forEach(line => {\r\n            let infoArr = line.info.split(\" \")[0].split(\"->\")\r\n            let source = infoArr[0]\r\n            let target = infoArr[1]\r\n            if (!this.scatterSet.has(source)) {\r\n                this.scatterSet.add(source)\r\n                let node = allNodes[source]\r\n                let { x, y, z } = node.coordinates\r\n                let { traffic, bdUtilization, type } = node\r\n                let color = type.indexOf(\"C\") > 0 ? [255, 0, 0] : [0, 0, 255]\r\n                let r_t = getScatterRadius(traffic, \"traffic\")\r\n                let r_b = getScatterRadius(bdUtilization, \"bd\")\r\n                Topnav.scatterData.bd.push({ info: source, position: [x, y, z], value: bdUtilization, radius: r_b, fillColor: color })\r\n                Topnav.scatterData.traffic.push({ info: source, position: [x, y, z], value: traffic, radius: r_t, fillColor: color })\r\n            }\r\n            if (!this.scatterSet.has(target)) {\r\n                this.scatterSet.add(target)\r\n                let node = allNodes[target]\r\n                let { x, y, z } = node.coordinates\r\n                let { traffic, bdUtilization, type } = node\r\n                let color = type.indexOf(\"C\") > 0 ? [255, 0, 0] : [0, 0, 255]\r\n                let r_t = getScatterRadius(traffic, \"traffic\")\r\n                let r_b = getScatterRadius(bdUtilization, \"bd\")\r\n                Topnav.scatterData.bd.push({ info: target, position: [x, y, z], value: bdUtilization, radius: r_b, fillColor: color })\r\n                Topnav.scatterData.traffic.push({ info: target, position: [x, y, z], value: traffic, radius: r_t, fillColor: color })\r\n            }\r\n        })\r\n\r\n    }\r\n\r\n    sendButtonStateInfo = () => {//把按钮的状态发送出去\r\n        let { dataKind, edgeKind, plane, netflow } = this.state\r\n        PubSub.publish(\"button\", { button: { dataKind, edgeKind, plane, netflow } })\r\n    }\r\n\r\n    componentDidUpdate() {\r\n        let { dataKind } = this.state\r\n        if (dataKind.traffic) this.setRightColumnDataKind({ dataKind: \"流量\" })\r\n        if (dataKind.bd) this.setRightColumnDataKind({ dataKind: \"带宽利用率\" })\r\n        //更新了按钮后，需要重新计算Map的layers\r\n        this.computeLayers()\r\n        this.combineLayers()\r\n\r\n    }\r\n\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"topnav\">\r\n                <button onClick={this.updateButtonState(\"traffic\")} style={{ backgroundColor: this.getButtonColor(\"traffic\") }}>流量</button>\r\n                <button onClick={this.updateButtonState(\"bd\")} style={{ backgroundColor: this.getButtonColor(\"bd\") }}>带宽利用率</button>\r\n                <button onClick={this.updateButtonState(\"EB\")} style={{ backgroundColor: this.getButtonColor(\"EB\") }}>边邦定</button>\r\n                <button onClick={this.updateButtonState(\"DC\")} style={{ backgroundColor: this.getButtonColor(\"DC\") }}>直连</button>\r\n                <button onClick={this.updateButtonState(\"A\")} style={{ backgroundColor: this.getButtonColor(\"A\") }}>A平面</button>\r\n                <button onClick={this.updateButtonState(\"B\")} style={{ backgroundColor: this.getButtonColor(\"B\") }}>B平面</button>\r\n                <button onClick={this.updateButtonState(\"netflow\")} style={{ backgroundColor: this.getButtonColor(\"netflow\") }}>Netflow</button>\r\n                {/* <button style={{ float: \"right\", marginRight: \"2px\" }}>自动分析</button> */}\r\n            </div>\r\n        )\r\n    }\r\n}","import React, { Component } from 'react'\r\nimport \"./index.css\"\r\nimport PubSub from \"pubsub-js\"\r\nimport Map from './map/index'\r\nexport default class LeftColumn extends Component {\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            isFinish: false\r\n        }\r\n    }\r\n\r\n    receiveDataInfo = () => {\r\n        PubSub.subscribe('data', (_, stateObj) => {\r\n            let { isFinish } = stateObj\r\n            this.setState({ isFinish })\r\n        });\r\n    }\r\n    componentDidMount() {\r\n        //接收来自data的信息\r\n        this.receiveDataInfo()\r\n    }\r\n    render() {\r\n        let { isFinish } = this.state\r\n        return (\r\n            <div className=\"leftcolumn\">\r\n                <div className=\"card\">\r\n                    <div className=\"map\" style={{ height: \"1200px\"}}>\r\n                        {\r\n                            !isFinish ?\r\n                                <h2>正在加载, 请稍后...</h2>\r\n                                :\r\n                                <Map />\r\n                        }\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}","import React, { Component } from 'react'\r\nimport PubSub from \"pubsub-js\"\r\nimport \"./index.css\"\r\nimport Map from '../leftColumn/map'\r\nimport Layer from '../leftColumn/map/Layer'\r\nimport provCityData from \"../leftColumn/data/prov_city.json\"\r\nimport Topnav from '../../topnav'\r\nexport default class RightColumn extends Component {\r\n\r\n    nodeThreshold = Infinity\r\n    edgeThreshold = Infinity\r\n    planeDiffThreshold = Infinity\r\n\r\n    static currentHover = \"\"\r\n\r\n    nodeRef = React.createRef()\r\n    edgeRef = React.createRef()\r\n    doublePlaneRef = React.createRef()\r\n\r\n    constructor(props) {\r\n        super(props)\r\n        this.state = {\r\n            dataKind: \"流量\",\r\n            myNodes: [],\r\n            myEdges: [],\r\n            myPlane: []\r\n        }\r\n        this.processProv2City()\r\n    }\r\n\r\n    componentDidMount() {\r\n        let setDataKind = this.setDataKind\r\n        PubSub.publish(\"rightDataKind\", { setDataKind })\r\n\r\n    }\r\n    setDataKind = (dataKind) => {\r\n        let dk = dataKind.dataKind\r\n        this.setState({ dataKind: dk, myNodes: [], myEdges: [], myPlane: [] })\r\n    }\r\n\r\n    processProv2City = () => {\r\n        let provData = provCityData[0]\r\n        let cityData = provCityData[1]\r\n        this.city2prov = {}\r\n        cityData.forEach(city => {\r\n            let cityName = city.name\r\n            let provID = city.ProID\r\n            for (let i = 0; i < provData.length; i++) {\r\n                let id = provData[i].ProID\r\n                let provName = provData[i].name\r\n                if (provID === id) {\r\n                    this.city2prov[cityName] = provName\r\n                    break;\r\n                }\r\n            }\r\n        })\r\n        console.log(\"city2prov\", this.city2prov)\r\n    }\r\n\r\n    updateTable = (kind, ref) => {\r\n        return () => {\r\n            let thresholdValue = ref.current.value\r\n            if (isNaN(thresholdValue) || thresholdValue === \"\") {\r\n                alert(\"请输入合法的数字\")\r\n                return false\r\n            }\r\n            if (kind === \"node\") {\r\n                if(Topnav.netflowExist){\r\n                    alert(\"请先取消netflow\")\r\n                    return false\r\n                } \r\n                this.nodeThreshold = thresholdValue\r\n                this.updateMyNodes()\r\n            }\r\n            if (kind === \"edge\") {\r\n                if(Topnav.netflowExist){\r\n                    alert(\"请先取消netflow\")\r\n                    return false\r\n                } \r\n                this.edgeThreshold = thresholdValue\r\n                this.updateMyEdges()\r\n            }\r\n            if (kind === \"doublePlane\") {\r\n                if (Topnav.currentPlane !== \"AB\"){\r\n                    alert(\"请同时选择A和B平面\")\r\n                    return false\r\n                } \r\n                if(Topnav.netflowExist){\r\n                    alert(\"请先取消netflow\")\r\n                    return false\r\n                } \r\n                this.planeDiffThreshold = thresholdValue\r\n                this.updateDoublePlane()\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    updateMyNodes = () => {\r\n        let myNodes = []\r\n        Map.currentScatterData.forEach(node => {\r\n            let { info, value, position, radius, fillColor } = node\r\n            if (value > this.nodeThreshold) {\r\n                let city = info.split(\",\")[0]\r\n                let dev = info.split(\",\")[1]\r\n                myNodes.push({ ID: info, city, dev, value, position, radius, fillColor })\r\n            }\r\n        })\r\n        myNodes.sort((a, b) => b.value - a.value)\r\n        this.setState({ myNodes })\r\n    }\r\n\r\n    updateMyEdges = () => {\r\n        let myEdges = []\r\n        Map.currentEdgeData.forEach(edgeArr => {\r\n            edgeArr.forEach(edge => {\r\n                let { path, value, color, info, width } = edge\r\n                if (value > this.edgeThreshold) {\r\n                    info = info.split(\" \")[0]\r\n                    let source = info.split(\"->\")[0]\r\n                    let target = info.split(\"->\")[1]\r\n                    myEdges.push({ ID: info, source, target, value, path, color, width })\r\n                }\r\n            })\r\n        })\r\n        myEdges.sort((a, b) => b.value - a.value)\r\n        this.setState({ myEdges })\r\n    }\r\n    updateDoublePlane = () => {\r\n        let myPlane = []\r\n\r\n        //先找到城市和省份的对应关系,这个只计算一次就可以了,这样不行，因为我可能会修改datakind\r\n        this.prov2city = {}\r\n        Map.currentScatterData.forEach(node => {\r\n            let { info, value } = node\r\n            let city = info.split(\",\")[0]\r\n            let dev = info.split(\",\")[1]\r\n            let ID = city + \",\" + dev\r\n            for (let attr in this.city2prov) {\r\n                if (attr.indexOf(city) > -1) {\r\n                    let prov = this.city2prov[attr]\r\n                    if (this.prov2city[prov] === undefined) this.prov2city[prov] = []\r\n                    this.prov2city[prov].push({ ID, prov, city, dev, value })\r\n                    break;\r\n                }\r\n            }\r\n        })\r\n\r\n        //再找该城市两台设备的value的百分比\r\n        for (let attr in this.prov2city) {\r\n            let sumValue = 0\r\n            this.prov2city[attr].forEach(line => {\r\n                sumValue = sumValue + line.value\r\n            })\r\n            let max = 0, min = Infinity\r\n            this.prov2city[attr].forEach(line => {\r\n                let percentage = line.value / sumValue\r\n                if (percentage > max) max = percentage\r\n                if (percentage < min) min = percentage\r\n            })\r\n            if ((max - min) > this.planeDiffThreshold) {\r\n                this.prov2city[attr].forEach(line => {\r\n                    line.diff = (max - min)\r\n                    myPlane.push(line)\r\n                })\r\n            }\r\n        }\r\n        //再将diff从大到小的顺序排列\r\n        myPlane.sort((a, b) => b.diff - a.diff)\r\n        this.setState({ myPlane })\r\n    }\r\n\r\n    hoverTr = (ID) => {\r\n        return () => {\r\n            if (RightColumn.currentHover === ID) return true\r\n            RightColumn.currentHover = ID\r\n            if (ID.indexOf(\"->\") < 0) {//高亮的是点\r\n                Layer.updateHighlightPoint_Edge(ID)\r\n            } else {//不然高亮的就是边\r\n                Layer.updateHighlightEdge(ID)\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    leaveTr = (ID) => {\r\n        return () => {\r\n            if (RightColumn.currentHover === \"\") return true\r\n            RightColumn.currentHover = \"\"\r\n            Layer.cancelHighlight()\r\n        }\r\n    }\r\n\r\n\r\n    render() {\r\n        let { dataKind, myNodes, myEdges, myPlane } = this.state\r\n        let title = \"---\" + dataKind\r\n        let content = \"请输入\" + dataKind + \"阈值\"\r\n        return (\r\n            <div className=\"rightcolumn\">\r\n                <div className=\"card\">\r\n                    <h3>拥塞节点{title}</h3>\r\n                    <input ref={this.nodeRef} type=\"text\" name=\"firstname\" placeholder={content}></input>\r\n                    <button onClick={this.updateTable(\"node\", this.nodeRef)}>确认</button>\r\n                    <div className=\"conclusion\" style={{ height: \"300px\" }}>\r\n                        <table className=\"myTable\" border=\"1\">\r\n                            <thead>\r\n                                <tr>\r\n                                    <th>城市</th>\r\n                                    <th>设备ID</th>\r\n                                    <th>{dataKind}</th>\r\n                                </tr>\r\n                            </thead>\r\n                            <tbody>\r\n                                {\r\n                                    myNodes.map(node => {\r\n                                        return (\r\n                                            <tr key={node.ID} onMouseOver={this.hoverTr(node.ID)} onMouseLeave={this.leaveTr(node.ID)}>\r\n                                                <td>{node.city}</td>\r\n                                                <td>{node.dev}</td>\r\n                                                <td>{node.value}</td>\r\n                                            </tr>\r\n                                        )\r\n                                    })\r\n                                }\r\n                            </tbody>\r\n\r\n                        </table>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className=\"card\">\r\n                    <h3>拥塞链路{title}</h3>\r\n                    <input ref={this.edgeRef} type=\"text\" name=\"firstname\" placeholder={content}></input>\r\n                    <button onClick={this.updateTable(\"edge\", this.edgeRef)}>确认</button>\r\n                    <div className=\"conclusion\" style={{ height: \"300px\" }}>\r\n                        <table className=\"myTable\" border=\"1\">\r\n                            <thead>\r\n                                <tr>\r\n                                    <th>城市1</th>\r\n                                    <th>城市2</th>\r\n                                    <th>{dataKind}</th>\r\n                                </tr>\r\n                            </thead>\r\n                            <tbody>\r\n                                {\r\n                                    myEdges.map(edge => {\r\n                                        return (\r\n                                            <tr key={edge.ID} onMouseOver={this.hoverTr(edge.ID)} onMouseLeave={this.leaveTr(edge.ID)}>\r\n                                                <td>{edge.source}</td>\r\n                                                <td>{edge.target}</td>\r\n                                                <td>{edge.value}</td>\r\n                                            </tr>\r\n                                        )\r\n                                    })\r\n                                }\r\n                            </tbody>\r\n\r\n                        </table>\r\n                    </div>\r\n                </div>\r\n\r\n                <div className=\"card\">\r\n                    <h3>双平面{title}</h3>\r\n                    <input ref={this.doublePlaneRef} type=\"text\" name=\"firstname\" placeholder={content}></input>\r\n                    <button onClick={this.updateTable(\"doublePlane\", this.doublePlaneRef)}>确认</button>\r\n                    <div className=\"conclusion\" style={{ height: \"300px\" }}>\r\n                        <table className=\"myTable\" border=\"1\">\r\n                            <thead>\r\n                                <tr>\r\n                                    <th>省份</th>\r\n                                    <th>城市</th>\r\n                                    <th>设备ID</th>\r\n                                    <th>diff</th>\r\n                                    <th>{dataKind}</th>\r\n                                </tr>\r\n                            </thead>\r\n                            <tbody>\r\n                                {\r\n                                    myPlane.map(node => {\r\n                                        return (\r\n                                            <tr key={node.ID} onMouseOver={this.hoverTr(node.ID)} onMouseLeave={this.leaveTr(node.ID)}>\r\n                                                <td>{node.prov}</td>\r\n                                                <td>{node.city}</td>\r\n                                                <td>{node.dev}</td>\r\n                                                <td>{node.diff.toFixed(2)}</td>\r\n                                                <td>{node.value}</td>\r\n                                            </tr>\r\n                                        )\r\n                                    })\r\n                                }\r\n\r\n                            </tbody>\r\n\r\n                        </table>\r\n                    </div>\r\n                </div>\r\n\r\n            </div>\r\n        )\r\n    }\r\n}","import React, { Component } from 'react'\r\nimport LeftColumn from './leftColumn'\r\nimport RightColumn from './rightColumn'\r\nimport \"./index.css\"\r\nexport default class Row extends Component {\r\n    render() {\r\n        return (\r\n            <div className=\"row\">\r\n                <LeftColumn/>\r\n                <RightColumn/>\r\n            </div>\r\n        )\r\n    }\r\n}","import React, { Component } from 'react'\r\nimport \"./index.css\"\r\nexport default class Footer extends Component {\r\n    render() {\r\n        return (\r\n            <div className=\"footer\">\r\n                <h2>感谢使用</h2>\r\n            </div>\r\n        )\r\n    }\r\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport Map from './components/row/leftColumn/map/index2';\nimport ComputeData from \"./components/row/leftColumn/map/ComputeData\"\nimport PubSub from \"pubsub-js\"\nimport ComputeNetflow from \"./components/row/leftColumn/map/ComputeNetflow\"\nimport Topnav from \"./components/topnav\"\nimport Row from \"./components/row\"\nimport Footer from './components/footer';\n\n\n\n\nReactDOM.render(\n  <React.StrictMode>\n    {/* <Map />,\n    <Conclusion/> */}\n    <Topnav/>\n    <Row/>\n    <Footer/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\nsetTimeout(() => {\n  let results = new ComputeData().getResults()\n  let netflowResults = new ComputeNetflow().getResults()\n  PubSub.publish(\"data\", { isFinish: true, results, netflowResults })\n}, 1);\n\n"],"sourceRoot":""}